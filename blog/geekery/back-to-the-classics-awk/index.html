<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <title>Back to the classics: awk || Fritz Stelluto</title>
  <meta name="author" content="gotofritz">
  <meta name="description" content="In this age of npm and github and easily available modules in any language of your choice, it is easy to forget the old Unix workhorses. Here&amp;#39;s a look at awk, a shell utility that allows you to treat and manipulate text files as if they were databases. In Part 2 there are a few sample scripts.">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link href="/assets/favicon.ico" rel="shortcut icon">
  <link rel="icon" href="/assets/favicon.gif" type="image/gif" />
  <link href="/assets/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
</head>

<body ontouchstart="">
  <header id="header" class="inner">
    <nav id="main-nav">
      <div>
        <a href="/">home</a>
        <a href="/blog/">blog</a>
      </div>
    </nav>

    <nav id="sub-nav" class="alignright">
      <form class="search" action="http://google.com/search" method="get">
        <input class="alignright" type="text" name="q" results="0">
        <input type="hidden" name="q" value="site:gotofritz.net">
      </form>
    </nav>
  </header>


<div id="content" class="inner">
  <article class="post">
    <h1 class="title">Back to the classics: awk</h1>
    <div>
      <div class="meta">
        <div class="date">
          <time datetime="2015-07-15T23:19:00+02:00" pubdate>2015-07-15</time>
        </div>
        <div class="tags">
          cli,
          awk
        </div>
      </div>
      <div class="entry-content">
    
<p>In this age of npm and github and easily available modules in any language of your choice, it is easy to forget the old Unix workhorses. Here&#39;s a look at awk, a shell utility that allows you to treat and manipulate text files as if they were databases. In <a href="/blog/geekery/a-selection-of-akw-scripts/">Part 2</a> there are a few sample scripts.</p>
<!--more-->

<h2 id="what-is-awk-">What is awk?</h2>
<p><code>Awk</code> is both the name of the command line utility, and the language used for it. It was invented at Bells Labs at the peak of punk rock, 1977, and its name is simply the initials of its three creators. Awk reads input (a file, or a stream) one line (one &quot;record&quot;) at the time, splits it into fields by blank space (these are all defaults that can be changed), and then uses the instructions in the awk language to manipulate these fields and generate some output. The ability to read files as streams is a big plus - it means the memory footprint is the same if you read a file of 1Kb or 200Tb; for a larger file it will just take longer.</p>
<p>Awk is standard with the version of bash that comes with OS X, and several others. There is another variant which is widespread - gawk, GNU awk. It is actually better than the original, because it offers array sort and length functions, the ability to include files, and more flexible rules for splitting input in fields. Here I will limit myself to the standard awk.</p>
<h3 id="example-awk-in-action">Example awk in action</h3>
<p>Here&#39;s what the simplest awk program looks like - this is basically <code>cat</code></p>
<pre><code># awk loads the short program: {print} and wait for user to type stuff
&gt; awk &#39;{print}&#39;
# as you type, the shell prints out what you are typing. Awk is waiting
# for a &lt;RETURN&gt; outside a &#39;&#39;
It was a bright cold day in April, and the clocks were striking thirteen.
# now awk kicks in and runs the program on the input
# {print} simply prints the input line as it is, so here it is again
It was a bright cold day in April, and the clocks were striking thirteen.</code></pre><p>The strong point of <code>awk</code> is that it automatically splits lines of text as if they were &quot;columns&quot; in a spreadsheet and assigns each column to a variable (a &quot;field&quot;). Then you can manipulate them and spit them out</p>
<pre><code># awk loads a slightly more complex program and waits
&gt; awk &#39;{print $3 &quot;: &quot; $1 + $2}&#39;
# waiting for a &lt;RETURN&gt; outside a &#39;&#39;
10 20 Toronto
# this line is split into 3 &quot;columns&quot;, and
# 10 is assigned to $1, 20 to $2, and Toronto to $3
# then the program {print &quot;$3: &quot; $1 + $2} is run - it adds $1 + $2 and
# prints the result out, with some extra text (the :)
Toronto: 30
# now it waits for the next line
20 30 Miami
# same program run on it
Miami: 50</code></pre><p>Despite its simplicity, you can take awk quite far - for example creating <a href="http://awk.info/?doc/story.html">a random sci-fi plot generator</a>.</p>
<h2 id="running-awk-programs-and-redirecting-input-output">Running awk programs and redirecting input, output</h2>
<p>Running awk on STDIN is not very useful, but of course you can use Unix magic to redirect the input and / or output of the program</p>
<pre><code># awk will treat the second argument as a path to a file to read from
&gt; awk &#39;{print}&#39; some_data.txt
... # prints whatever was in some_data.txt
&gt;
# exactly the same thing but done differently - redirecting file to STDIN
&gt; awk &#39;{print}&#39; &lt; some_data.txt
... # prints whatever was in some_data.txt
&gt;
# you can read several files, in order
&gt; awk &#39;{print}&#39; some_data.txt more_data.txt
...
&gt;
# now the processed data goes to a separate file
&gt; awk &#39;{print}&#39; some_data.txt &gt; result.txt
&gt;
# the awk program itself can be loaded to a file - here this file is created
&gt; echo &#39;{print}&#39; &gt; awk.txt
# passing the command on to awk with the -f option
&gt; awk -f awk.txt some_data.txt &gt; result.txt
&gt;
# mixing STDIN with files. The &quot;-&quot; is substituted by STDIN,  which is dealt with
# after some_data.txt
&gt; ls -l | awk &#39;{print}&#39; some_data.txt - more_data.txt
&gt; ... # prints all lines from some_data.txt
&gt; ... # prints result of ls -l (this is the &quot;-&quot;)
&gt; ... # prints all lines from more_data.txt
&gt;
# pass some text into awk, then run an awk program on it
&gt; echo &#39;1 2 3&#39; | awk &#39;{print}&#39;
&gt; 1 2 3
&gt;
# using the curl util to download a csv file, piping it to awk, and running
# the simple awk program on it
&gt; curl http://is.gd/eUrbOZ | awk &#39;{print}&#39;
Forename,Surname,Description on ballot paper,Constituency Name,PANo,Votes,Share
... # etc</code></pre><h2 id="anatomy-of-an-awk-program">Anatomy of an awk program</h2>
<p>So far the awk example consisted of simple one liners - but awk programs can consist of several instructions (&quot;actions&quot;). You can still write them out on the shell:</p>
<pre><code># note: the &quot;&gt;&quot; is added automatically when hitting return inside a &#39;&#39;,
# and the space between &gt; and { was added manually to make it line up
&gt; awk &#39;{print}
&gt;      {print}
&gt;      {print}&#39;
# now that the closing &#39; was typed, awk kicks in. this programs simply
# prints out whatever you type three times
oh # typed by you
oh # printed by awk 3 times
oh
oh</code></pre><p>In this tutorial I will put the awk program in its own file and load it from the command line - just to make formatting easier and allow comments. The file loaded here has suffix &quot;.awk&quot; but that&#39;s irrelevant, it could be any filename.</p>
<pre><code>&gt; awk -f example.awk some_input_text.txt</code></pre><p>An awk program consists of a list of actions, one after the other, and typically one per line (they can be broken up though). There are two special types of actions - BEGIN actions are executed only once, before the text is scanned, and END only once, afterwards. All other actions are executed in order on every line of text. Assume your input file includes increasing integers, one per line</p>
<pre><code>1
2
3</code></pre><p>Then the program below</p>
<pre><code>BEGIN { print &quot;START!&quot; }
{print &quot;--------------&quot;}
{print}
{print}
{print}
END { print &quot;END!&quot; }</code></pre><p>Would produce</p>
<pre><code>START!
--------------
1
1
1
--------------
2
2
2
--------------
3
3
3
END!</code></pre><p>Note that actions can be in any order (they will be executed in the order they are written) and there can be multiple BEGIN and END, so the following is also a legal program.</p>
<pre><code>{print &quot;--------------&quot;}
{print}
END { print &quot;END!&quot; }
BEGIN { print &quot;START!&quot; }
{print}
END { print &quot;Copyright 2005&quot; }
{print}</code></pre><p>The way the program is dealt with is:</p>
<ul>
<li>all the BEGIN actions are executed, in order</li>
<li>input is read one line at the time, and for each line<ul>
<li>the line is split into fields</li>
<li>each action, in turn, is run on the fields</li>
</ul>
</li>
<li>all the END actions are run at the end</li>
</ul>
<p>Inside the actions awk offers what most programming languages offer - variable, loops, tests, etc.</p>
<h3 id="actions-formatting">Actions formatting</h3>
<p>Awk follows Unix conventions on most things, so in case of doubt whatever works in Bash scripts tends to work.</p>
<pre><code># a &#39;normal&#39; one lne
BEGIN { print &quot;START&quot; }
# you can add newlines for formatting - this is equivalent to the above
BEGIN {
  print &quot;START&quot;
}
-&gt; START
-&gt; START

# as in Bash scripts, you can use the semicolon to separate multiple statements
# on the same line...
BEGIN { print &quot;STA&quot;; print &quot;RT&quot;;}
# or you can write them one per line, with or without semicolon
BEGIN { print &quot;STA&quot;
        print &quot;RT&quot; }
-&gt; STA
  RT
-&gt; STA
  RT</code></pre><h2 id="variables">Variables</h2>
<p>Awk makes several variables available to the programs - some are loaded when the program is launched, some are updated with each line read, some are created by the program itself.</p>
<h3 id="field-variables">Field Variables</h3>
<p>Whenever awk reads a line, it splits it into &quot;fields&quot; by white-space / tab (this is the default and can be overridden), Then each field is copied to a variable $1, $2, .... in order - there is no limit. Additionally, $0 contains the whole line.</p>
<pre><code># assume this file
1 2 3 4 5 6 7

# the following two lines are equivalent
{ print }
{ print $0 }
-&gt; 1 2 3 4 5 6 7
-&gt; 1 2 3 4 5 6 7

# only prints some fields we are interested in
{ print $1 &quot; &quot; $3 }
-&gt; 1 3</code></pre><p>The field number doesn&#39;t have to be a constant - it can be an expression or a variable. For example, the global variable NF contains the number of the last field and is updated which every line read. So if there are 7 fields, NF would be 7, and $NF would be $7, i.e. the last field</p>
<pre><code># assume this file
1 2 3 4 5 6 7

# both mean first and last field - but the first version only works if there are
# 7 fields, the second always works
{print $1 &quot; &quot; $7}
{print $1 &quot; &quot; $NF}
-&gt; 1 7
-&gt; 1 7
#
# print the last two fields
{print $(NF-1) &quot; &quot; $NF}
-&gt; 6 7</code></pre><p>Another useful global variable that gets updated for each record is NR - this is the record number</p>
<pre><code># feed a four line input into awk
&gt; echo &#39;a
&gt; b
&gt; c
&gt; d&#39; | awk &#39;{print NR &quot;) &quot; $1}&#39;
# it prints the line number, ), and the first (and only) field
1) a
2) b
3) c
4) d</code></pre><p>You can assign to a field variable with the &#39;=&#39; operator, thereby changing the record content:</p>
<pre><code># adding something to a field - will only works if it&#39;s a number
{$3 = ($3 + 100)
# now print the updated line
print $0}
-&gt; 1 2 103 4 5 6 7</code></pre><p>If you assign to a field variable that doesn&#39;t exist, it will be added to the record</p>
<pre><code># the record only contains $1 and $2;
&gt; echo 1 2 | awk &#39;{print $0}&#39;
&gt; 1 2
&gt;
# the program adds two new fields
&gt; echo 1 2 | awk &#39;{$3 = 3; $4 = 4; print $0}&#39;
&gt; 1 2 3 4</code></pre><h3 id="global-variables">Global variables</h3>
<p>A few variables are set when the program is launched. Here&#39;s a very short list - if you need to play with these you probably want to get yourself a book on awk.</p>
<table>
  <tr>
    <th>Variable</th><th></th>
  </tr>
  <tr><td>ARGV</td><td>array of command line arguments</td></tr>
  <tr><td>ARGC</td><td>number of command line arguments</td></tr>
  <tr><td>ENVIRON</td><td>associative array with environment. Depends on system</td></tr>
  <tr><td>FILENAME</td><td>self explanatory</td></tr>
</table>

<h3 id="user-defined-variables">User defined variables</h3>
<p>To create your own variable, just start assigning to them with the &#39;=&#39; operator - awk will initialize them to an emptry string (which becomes a 0 if used in numeric context). The type of variable is dynamic and can vary during its lifetime.</p>
<p>In the example below, awk is used on the ls command to find the total size of a folder.</p>
<pre><code># ls -la returns listings in the form:
# -rw-rw-r--    1 gotofritz staff   1513 Dec 15  2013 .bash_profile
# awk simply collects each filesize and adds it to a running total,
# then prints it at the end
&gt; ls -la | awk &#39;    { total += $5 }
                END { print total }&#39;
-&gt; 158448</code></pre><h3 id="arrays">Arrays</h3>
<p>Awk has associative arrays, similar to PHP&#39;s or Javascript. You create an array by using it, no need to initialize it.</p>
<pre><code># assume this file
10 Life changes fast
20 Life changes in the instant
30 You sit down to dinner and life as you know it ends
40 The question of self-pity

# creates my_array and inserts all lines into it
{ my_array[$1] = $2 }
# creates - note that array is sparse
my_array[10] = &quot;Life changes fast&quot;
my_array[20] = &quot;Life changes in the instant&quot;
my_array[30] = &quot;You sit down to dinner and life as you know it ends&quot;
my_array[40] = &quot;The question of self-pity&quot;

# string keys are also possible
{ my_array[&quot;name&quot;] = &quot;Homer&quot; }</code></pre><p>One thing that is different in awk is that multidimensional arrays use a single set of square brackets to wrap both indices</p>
<pre><code># assume this file
dad homer
mum marge
son bart

# creates a two dimensional array
{ family[&quot;simpsons&quot;,$1] = $2 }
-&gt; creates
family[&quot;simpsons&quot;,&quot;dad&quot;] = &quot;homer&quot;
family[&quot;simpsons&quot;,&quot;mum&quot;] = &quot;marge&quot;
family[&quot;simpsons&quot;,&quot;son&quot;] = &quot;bart&quot;</code></pre><p>Note that arrays in awk are pretty awkward. There are no built in functions to deal with them except for the for ... in loop. If you need to sort, or even just find out the length, you&#39;ll have to write your own functions. There are a couple in <a href="/blog/geekery/a-selection-of-akw-scripts/">Part 2</a>. Alternatively, use gawk which has <a href="https://www.gnu.org/software/gawk/manual/gawk.html#Arrays">better array handling</a>.</p>
<h3 id="regular-expressions">Regular expressions</h3>
<p>A regular expression (regexp) is a mini programming language which is used to describe variable strings; it is embedded in most programming languages.
Regexps are enclosed in slashes and use a combination of literal characters and punctuation to describe strings. The operator ~ is used to match a regexp, and !~ to ensure it is not matched.</p>
<p>Regular expressions is a complicated topic of its own; here is just a quick introduction</p>
<pre><code># print all lines with &quot;gmail&quot; in the 1st field
{ if ($1 ~ /gmail/) print}

# prints all lines EXCEPT those with &quot;gmail&quot;
{ if ($1 !~ /gmail/) print}

# ^ indicates start of string.
# this matches &quot;tom&quot; &quot;tomato&quot; but not &quot;atom&quot;
{ if ($1 ~ /^tom/) print}

# $ indicates end of string
# this matches &quot;tom&quot;, &quot;atom&quot; but not &quot;tomato&quot;
{ if ($1 ~ /tom$/) print}

# this matches &quot;tom&quot;, not &quot;atom&quot; and not &quot;tomato&quot;
{ if ($1 ~ /^tom$/) print}

# . matches any character.
# this matches &quot;bear&quot; &quot;boar&quot; but not &quot;bar&quot;
{ if ($1 ~ /b..r/) print}

# [ABC] matches one character from the set &quot;A&quot;, &quot;B&quot;, &quot;C&quot;
# this matches &quot;boar&quot; &quot;bear&quot; but not &quot;blar&quot;
{ if ($1 ~ /b[oe]ar/) print}

# [^ABC] matches one character which is anything except &quot;A&quot;, &quot;B&quot;, &quot;C&quot;
# this matches &quot;blar&quot; but neither &quot;boar&quot; nor &quot;bear&quot;
{ if ($1 ~ /b[^oe]ar/) print}

# (abc) groups the expression abc as a unit.
# | is an &quot;or&quot;
# \ is used to scape special characters, i.e. treat them as normal characters
# in this case we want to treat the &#39;.&#39; as a period and not &quot;any character&quot;
# the following matches @gmail.com or @yahoo.com
{ if ($1 ~ /@(gmail)|(yahoo)\.com/) print}

# * means repeat zero or more. + is repeat once or more. ? is repeat 0 or 1
{ if ($1 ~ /&lt;[^&gt;]+&gt;[^&lt;]*&lt;/[^&gt;]+&gt;\.?/) print }
# the following matches &lt; followed by one or more (+) of anything except &gt;, then &gt;
# then zero or more (*) of anything except &lt;
# then &lt;/ followed by one or more (+) of anything except &gt;, then &gt;
# then an optional .</code></pre><h2 id="statements-operators-and-function">Statements, operators, and function</h2>
<h3 id="control-statements">Control statements</h3>
<p>Awk has the usual loops and conditionals familiar from C. Braces are optional for single nested statements</p>
<pre><code># braces are optional for single statements
for (name in list_of_names)
  print name

for (capital_city in country) {
  print capital_city
}

# but needed for multiple statements
if (NR % 2 == 0) {
  $2 = $1 * 2
  print $0
}</code></pre><h4 id="if-else">if-else</h4>
<p>Awk doesn&#39;t have booleans. Instead it treats the number 0 or the empty string &quot;&quot; as false, and any other value (including the string &quot;0&quot;) as true. The comparison operators are the familiar ones, with double equal sign for equality, plus the tilde ~ and !~ for regular expression matching, and &quot;in&quot; for array existence</p>
<pre><code>{ if ($1 == &quot;full&quot;) ... }
{ if ($2 &lt; 0.5) ... }
{ if ($0 ~ /Republican/) print $0 } ... # matches regexp
{ if ($1 !~ /Completed/) print $0 } ... # rejects regexp
{ if (capital_city in country) print country[&quot;capital_city&quot;] }</code></pre><h4 id="loops">loops</h4>
<p>Awk has both for and while loops (including do-while). Additionally, there is the for-in loop for sparse arrays</p>
<pre><code># assume file
1 10 100
2 20 200

# both these programs will print each line with fields back-to-front
# while loop version...
{ i = NF
  line = &quot;&quot;
  while (i) {
    line =  line &quot; &quot; $i
    i--
  }
  print line
}
# for loop version
{ line = &quot;&quot;
  for (i=NF; i&gt;0; i--) {
    line =  line &quot; &quot; $i
  }
  print line
}
-&gt; 100 10 1
  200 20 2

# puts each line of input into the array
{ lines[$NR] = $0 }
# at end prints all the lines
END {
  for (line in lines)
    print line
}</code></pre><p><code>break</code> and <code>continue</code> statements are available to exit a loop prematurely or skipping an iteration respectively.</p>
<h4 id="next">next</h4>
<p><code>next</code> is used to stop precessing a record and moving on to the next</p>
<pre><code>{ if ($5 == &quot;&quot;) next }
{ print $5 $4 }</code></pre><h3 id="awk-numeric-operators">Awk numeric operators</h3>
<p>The usual maths operators can be used: +, -, /, * , ++, -- plus % for modulus, ^ for exponentiation. Unary + converts to a number</p>
<pre><code>echo &quot;1
&gt; 2
&gt; 3
&gt; 4&quot; | awk &#39;{print $1 ^ 2}&#39;
1
4
9
16</code></pre><h3 id="string-concatenation">String concatenation</h3>
<p>Concatenating string in awk is slightly weird. There is no string concatenation operator; just put the strings next to each other. Because of that it is recommended to use parenthesis except for trivial cases. Alternatively, <code>print</code> can take multiple comma separated arguments - and they will be printed with a space separating them</p>
<pre><code># assume this file
1
2
3
4

# the strings ($1..) and &quot;a&quot; are concatenated (no space between them) and
# the resulting string is passed to print
{print ($1+2) &quot;a&quot;}
3a
4a
5a
6a

# two separate strings are passed to print -  a space is put between them
{print ($1+2), &quot;a&quot;}
3 a
4 a
5 a
6 a

# string concatenation works for variables too
{ something = $1 &quot;--&quot;
  print something }
1--
2--
3--
4--</code></pre><h3 id="built-in-functions">Built in functions</h3>
<p>There are a number of built in functions: numeric ones like cosine, square root, random; string functions like print or string length; time functions and bitwise functions. You can easily find out what they are by looking at the output of <code>man awk</code>.</p>
<p>Worth nothing that besides <code>print</code> awk also offers <code>printf</code>, i.e. &quot;print formatted&quot;. Printf is common to many Unix tools and languages. You give a string with some placeholders and rules, and then you pass variables to &quot;plug in&quot; those placeholders. The important thing is the rules, which control things like right alignment, decimal precision, zero padding for numbers, etc. A statement looks like this:</p>
<pre><code>{ printf &quot;%-10s %04.3f%% \n&quot;, $1, $2 }
# placeholders start with %
# %-10s is a string (s), and is left aligned (-) within a field 10 spaces wide (10)
# %07.3f is a decimal number or float (f), the toal length has to be at least 7
#        characters (7) and is padded with zeroes if too small (0) and has
#        3 decimals (3) and minimum 3 in the integer part (7 - 3 decimals - the point)
# %% if you want to print an actual %, you need to type it twice %%
# \n you need to supply the new line manually</code></pre><p><a href="http://www.math.utah.edu/docs/info/gawk_7.html#SEC61">More information on printf</a>.</p>
<h3 id="user-defined-functions">User defined functions</h3>
<p>You can define functions anywhere in your code, outside actions. They are pretty similar to Javascript</p>
<pre><code># define funtion outside rules - could be at the bottom of file
function my_func(field_content) {
  print &quot;FIELD: &quot; field_content
}

# now use in rules
{my_func($1)}</code></pre><h2 id="patterns">Patterns</h2>
<p>Previously I described an awk program as a series of actions, with the special case of BEGIN and END. That&#39;s not entirely correct. An awk program consists of a sequence of actions and optional <em>patterns</em>; BEGIN and END are two special patterns. Incidentally, there is also a BEGINFILE and ENDFILE, for when processing more than one file at the time.</p>
<p>BEGIN and END are special because they identify actions which are not executed for every line of input, but before or after the whole program is run. The other patterns are used on every line to determine whether the action should be run for that particular line or not. Patterns are espressions that return false (i.e., 0 or &quot;&quot;) or true (anything else). When the pattern returns true, the rules is executed.</p>
<h3 id="regular-expression-patterns">Regular expression patterns</h3>
<p>Regular expressions can be used as pattern; they match the entire line. An exclamation mark reverses the match. Boolean operators can be used to combine patterns</p>
<pre><code># print lines with an email address
# (very lazy match - will only work if all email addresses are well formed)
/@/ { print $3}

# prints all lines except those with a gmail address
! /@gmail\./ { print $0 }

# prints lines with an @ and the sequence 0160
/@/ &amp;&amp; /0160/ { print }</code></pre><p>The regular expressions above are a shortcut for <code>$0 ~ /pattern/</code>, i.e. &quot;apply the regexp to whole line&quot;. Similar rules can be made for individual fields...</p>
<pre><code># matches only the regx on one field
$1 ~ /Anthony/ { print }</code></pre><p>..and all expressions seen so far</p>
<pre><code># print even lines
NR % 2 == 0 { print }

# print only if length of 1st field is greater than 3
# length is a string function mentioned above
length($1) &gt; 3 { print }</code></pre><p>The reason we have been able to run program without patterns is because there is a special pattern, the empty pattern, which matches every line. In fact we could have a program which is just a pattern; the default action <code>{print}</code> would be executed.</p>
<pre><code># prints whole line, default action
$1 == &quot;complete&quot;</code></pre><h2 id="splitting-records-and-fields-differently-from-default">Splitting records and fields differently from default</h2>
<p>By default awk treats each line as a record. In reality what it does is to split the input by a record separator, stored in the variable RS, which happens to be the new line character. You can change that in an awk program.</p>
<pre><code># separate records by semicolon
&gt; echo &quot;1 2 3;4 5 6;7 8 9&quot; | awk &#39;BEGIN {RS = &quot;;&quot; }
&gt;                                 {print}&#39;
1 2 3
4 5 6
7 8 9</code></pre><p>Something similar is possible with the field separator, which is stored in the variable FS. By default it is equal to the regexp <code>[ \t\n]+</code>, i.e. any number of consectuve spaces of any type. Note that in reality awk cheats - leaving FS default doesn&#39;t just mean setting it to <code>[ \t\n]+</code>, but also trimming $0 of leading and trailing empty space before processing it.</p>
<pre><code># separate fields by comma
&gt; echo &quot;1,2,3
4,5,6
7,8,9&quot; | awk &#39;BEGIN {FS = &quot;,&quot; }
&gt;             {print}&#39;
1,2,3
4,5,6
7,8,9</code></pre><p>You can combine the two together if, for example, your data has one field per line and records are separated by multiple lines - an empty RS means &quot;any number of consecutive \n &quot;&quot;</p>
<pre><code># assume this data
homer simpson
dad

marge simpson
mum

# separate records by any number of newlines, and have one field per line
BEGIN {RS=&quot;&quot;; FS=&quot;\n&quot;}
{ print $1 &quot; (&quot; $2 &quot;)&quot; }

-&gt; homer simpson (dad)
  marge simpson (mum)</code></pre><h2 id="passing-option-to-awk">Passing option to awk</h2>
<p>A field separator (but not a record separator) can be also passed to an awk program in two ways. First of all, awk has a special option for it, -F (note that there is no space between it and the separator). And awk allow passing of variables with the -v syntax, so you could just pass FS that way.</p>
<pre><code># change separator from within program
BEGIN {FS = &quot;,&quot; }

# pass separator with special option -F - note that you don&#39;t need quotes
&gt; echo &quot;1,2,3
&gt; 4,5,6&quot; | awk -F, &#39;{print}&#39;
1,2,3
4,5,6

# pass separator as external var with -v
&gt; echo &quot;1,2,3
&gt; 4,5,6&quot; | awk -v FS=&quot;,&quot; &#39;{print}&#39;
1,2,3
4,5,6i

# in fact you can pass any variable of your choice with -v
&gt; echo &quot;&quot; | awk -v WHAT=&quot;grow up&quot; &#39;{print &quot;All children, except one, &quot; WHAT}&#39;
All children, except one, grow up</code></pre><h2 id="reading-csv-files-in-awk">Reading CSV files in awk</h2>
<p>The naive approach would be to simply set FS=&quot;,&quot; - but that doesn&#39;t cover the fact that some fields are surrounded by quotation marks and others aren&#39;t, and sometimes you have newlines and / or commas inside a field. <a href="http://www.linuxquestions.org/questions/programming-9/awk-with-csv-files-881103/">Here are some examples scripts</a> people have put together to solve the issues. They are also good examples of fairly complex awk scripts.</p>
<p>Personally I think that&#39;s taking things too far - if you have to force awk to create arrays to store  manipulated record fragments you may as well use a fully fledged scripting language.</p>
<p>Another approach is to use gawk, and <a href="https://www.gnu.org/software/gawk/manual/gawk.html#Splitting-By-Content">its FPAT variable</a></p>
<h2 id="learning-more-about-awk">Learning more about awk</h2>
<p>With that all the main awk topics were touched on. If you want to go deeper I recomend <a href="http://www.staff.science.uu.nl/~oostr102/docs/nawk/nawk_toc.html">The AWK Manual</a>, or <a href="http://shop.oreilly.com/product/9780596000707.do">one of the O&#39;Reilly books</a></p>

      </div>
    </div>
  </article>


<!-- <section id="comment">
    <h1 class="title">Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
</section>

  </div>
  -->
  <footer id="footer" class="inner">Copyright &copy; 2016

    Fritz Stelluto

</footer>
<!--
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
<script type="text/javascript">
      var disqus_shortname = 'goto-fritz';


        // var disqus_developer = 1;
        var disqus_identifier = 'http://gotofritz.net/blog/geekery/backing-up-hard-disk-os-x/';
        var disqus_url = 'http://gotofritz.net/blog/geekery/backing-up-hard-disk-os-x/';
        var disqus_script = 'embed.js';

    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>
-->


  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-11254155-2']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>

</body>
</html>