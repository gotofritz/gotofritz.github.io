<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <title>CSS Selectors in 2017 || Fritz Stelluto</title>
  <meta name="author" content="gotofritz">
  <meta name="description" content="Where are we at with Level 4 CSS Selectors in 2017? In short, nowhere. A lot of pseudo-classes were added (including the one we are all crying out for, :has) but manufacturers don&amp;#39;t seem interested in implementing them.">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link href="/assets/favicon.ico" rel="shortcut icon">
  <link rel="icon" href="/assets/favicon.gif" type="image/gif" />
  <link href="/assets/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
</head>

<body ontouchstart="">
  <header id="header" class="inner">
    <nav id="main-nav">
      <div>
        <a href="/">home</a>
        <a href="/blog/">blog</a>
      </div>
    </nav>

    <nav id="sub-nav" class="alignright">
      <form class="search" action="http://google.com/search" method="get">
        <input class="alignright" type="text" name="q" results="0">
        <input type="hidden" name="q" value="site:gotofritz.net">
      </form>
    </nav>
  </header>


<div id="content" class="inner">
  <article class="post">
    <h1 class="title">CSS Selectors in 2017</h1>
    <div>
      <div class="meta">
        <div class="date">
          <time datetime="2017-06-10T13:44:00+02:00" pubdate>2017-06-10</time>
        </div>
        <div class="tags">
          css
        </div>
      </div>
      <div class="entry-content">
    
<p>Where are we at with <a href="https://drafts.csswg.org/selectors/">Level 4 CSS Selectors</a> in 2017? In short, nowhere. A lot of pseudo-classes were added (including the one we are all crying out for, :has) but manufacturers don&#39;t seem interested in implementing them.
<!--more--></p>
<p>CSS is a language for describing the rendering of document with a <abbr title="Document Object Model">DOM</abbr>. Selectors are a core component of CSS, and can be used in JS too, to locate DOM nodes.</p>
<p>The basic builing blocks are the seven types of <strong>simple selectors</strong>: <a href="#universal-selector">Universal selector</a>, <a href="#type-selector">Type selector</a>, <a href="#id-selector">Id selector</a>, <a href="#class-selector">Class selector</a>, <a href="#attribute-selector">Attribute selector</a>, <a href="#pseudo-classes">Pseudo-classes</a>,  <a href="#pseudo-elements">Pseudo-elements</a>. <code>*</code>, <code>form</code>, <code>#login</code>, <code>.error</code>, <code>[rel=&#39;nofollow&#39;]</code>, <code>:first-child</code>, <code>::before</code> are all examples of simple selectors. They can be used as they are, but often they are not specific enough. Most of the simple selectors have been around forever and are well established; most of the Level 4 work has been in adding or expanding to pseudo-classes.</p>
<p>Simple selectors can be combined in a sequence (without white spaces) to create <strong>compound selectors</strong>, which are often more specific. All the simple selectors that make up a compound selector must match, in any order. The only rule is that there can only be a single Universal or Type selector, and if present it must be the first. <code>*:first-child</code>, <code>input.error.important</code>, <code>#login[data-attempts=&#39;3&#39;]</code>, <code>a[rel=&#39;nofollow&#39;]::before</code> are examples of compound selectors.</p>
<p>Simple or compound selectors can be combined with <a href="#combinators">Combinators</a> to create <strong>complex selectors</strong>. Combinators are operators that tell the engine something about DOM nodes around the one you are selecting, which is always the last one in the selector. So in <code>a &gt; *:first-child</code> the combinator <code>&gt;</code> is used to combine the simple selector <code>a</code> with the compound selector <code>*:first-child</code> (which is made up of the simple selectors <code>*</code> and <code>:first-child</code>). The subject of the selector is <code>*:first-child</code>; the other part, <code>a &gt;</code> is not being selected, it&#39;s just context, so CSS rules won&#39;t be applied to it.</p>
<p>Finally, simple, compound, or complex selectors can be combined in selector lists using the list operator <code>,</code>. A selector list will match if any selector within it matches. <code>a:hover, a:visited</code> is an example of a selector list.</p>
<p>To summarise:</p>
<ul>
<li><code>a</code> is a <em>simple selector</em> that will match all links</li>
<li><code>a:hover</code> is a <em>compound selector</em> that will match all elements which are links AND are being hovered on</li>
<li><code>a :hover</code> (note the space) is a <em>complex selector</em> that will match all elements which are being hovered on, but only if one of their ancestors is a link (probably a mistake)</li>
<li><code>a, :hover</code> is a <em>selector list</em> that will match either a link OR any element being hovered on</li>
</ul>
<p><h2 id="universal-selector">Universal selector, *</h2>
Nothing new here. This selector matches everything<sup>*</sup> and it is only necessary for when that&#39;s exactly whay you need. Typical example is setting the box-sizing property:</p>
<pre><code>* { box-sizing: border-box; }
</code></pre><div class="note">
* strictly speaking the universal selector only matches element which are not <em>featurless</em>, which is the case for some shadow-dom elements.
</div>

<p>Otherwise it&#39;s redundant. All the pairs below do exactly the same thing</p>
<pre><code>*[rel=&#39;nofollow&#39;] { .. }
[rel=&#39;nofollow&#39;] { .. }

*.error { ... }
.error { ... }

*:first-child { ... }
:first-child { ... }
</code></pre><p>However, it may make sense to use it anyway, for added clarity. For example below one may miss out the space between <code>nav</code> and <code>:first-child</code> when scanning the code quickly. The <code>*</code> makes it obvious</p>
<pre><code>nav :first-child { ... }
nav *:first-child { ... }
</code></pre><p><h2 id="type-selector">Type selector, i.e. element name</h2>
This is basically the name of a tag or element - <em>input</em>, <em>textarea</em>, _a_, <em>component</em>, <em>nav</em> ... there is nothing new or interesting about these, which exist since the beginning of CSS. They are case insensitive.</p>
<pre><code>a { ... }
li { ... }
</code></pre><p><h2 id="class-selector">Class selectors</h2>
Another simple at exists since the beginning of time. Nothing new happening here either; they remain case-sensitive (unless the document is in quirks mode, which luckily is now pretty much a historical curiosity). This could be replaced with the attribute selector for whitespace-separated lists</p>
<pre><code>.error { ... }
[class~=error] { ... }

.error.severe { ... }
[class~=error][class~=severe] { ... }
</code></pre><p><h2 id="id-selector">Id selectors</h2>
Yep. Same old simple selector, nothing new here either. Of course, nobody uses them anymore, right?</p>
<pre><code>#myId { ... }
[id=&#39;myId&#39;] { ... }
</code></pre><p><h2 id="attribute-selector">Attribute selectors</h2>
A powerful family of simple selectors which also has been around for a while.</p>
<p class="close-to-next">You can select only elements which have a certain attribute, regardless of value</p>

<pre><code>[rel] { .. }
</code></pre><p class="space-around">Or you can treat the value as a single string, and match either the complete string, or parts of it, trating spaces as just another character.</p>

<pre><code>[rel=&#39;nofollow&#39;] { .. }
</code></pre><p class="close-to-previous">This will match any element with a rel attribute which is exactly &#39;nofollow&#39;. This will not match rel=&quot;nofollow noreferrer&quot;</p>

<pre><code>[rel=&#39;nofollow noreferrer&#39;] { .. }
</code></pre><p class="close-to-previous">This <em>will</em> match &quot;nofollow noreferrer&quot;, but not &quot;noreferrer nofollow&quot;, which is why it is never a good idea to have selectors with spaces in them (unless we are talking strings in data attributes, like &quot;new york&quot; and so on)</p>

<pre><code>[rel*=&#39;nofollow][rel*=&#39;noreferrer&#39;] { .. }
</code></pre><p class="close-to-previous">This compound selector is a safer way to find elements with two values; this will handle both rel=&quot;noreferrer nofollow&quot; and rel=&quot;nofollow noreferrer&quot;. But the <code>~=</code> operator (see below) is better, as it was designed for that purpose</p>

<pre><code>a[href^=&#39;http:&#39;] { .. }
</code></pre><p class="close-to-previous"><code>^=</code> is the &#39;starts with` selector. This matches all links if their href href attribute starts with &#39;http:&#39;, i.e. all links to non-https sites</p>

<pre><code>a[href$=&#39;index.html&#39;] { border: 10px solid red; }
</code></pre><p class="close-to-previous"><code>$=</code> is the companion of the previous one, the &#39;ends with&#39; selector. You can use this to visually mark all the links which have the pointless &quot;index.html&quot; at the end</p>

<pre><code>a[href*=&#39;amazon&#39;] { .. }
</code></pre><p class="close-to-previous">And finally <code>*=</code>, the &#39;anywhere&#39; selector; matches all links with an href which includes &#39;amazon&#39; anywhere (including beginning or end).</p>

<p class="space-around">The attribute selectors above treat the value of the attribute as a single string. There are two operators that treat it as a sequence of patterns</p>

<pre><code>a[rel~=&#39;nofollow`] { ... }
</code></pre><p class="close-to-previous">The <code>~=</code> operator treats the strings as a whitespace separated list, and tries to match the string against every item in the list. The above will match &quot;nofollow&quot;, &quot;noreferrer nofollow&quot; and &quot;nofollow noreferrer&quot;</p>

<pre><code>/* these two are equivalent */
title[lang|=&#39;fr&#39;] { .. }

title[lang^=&#39;fr-&#39;], title[lang=&#39;fr&#39;]  { .. }
</code></pre><p class="close-to-previous">The <code>|=</code> operator was created mostly to match locales and languages. It either treats the string as a complete match (<code>fr</code>), or as the beginning of a dash separated sequence (<code>fr-fr</code>, <code>fr-be</code> etc). in theory it shouldn&#39;t be actually very useful for language matching, because it only matches element with an actual lang attribute. For safe language matching, the <code>:lang</code> pseudo-class was created. But that&#39;s not fully supported. Having said that, I am yet to see elements with actual different lang attributes on the same document in a real life situation. <strong>TL;DR pretty useless</strong></p>

<h3 id="new-case-insensitive-attribute-values">New: case insensitive attribute values</h3>
<pre><code>[data-location=&#39;Paris&#39;]   { .. }  /* case sensitive version */
[data-location=&#39;paris&#39; i] { .. }  /* case insensitive version */
</code></pre><p class="close-to-previous">All the matchers are case-sensitive by default, but there is a case-insensitive operator that can be added to the selector. <a href="https://caniuse.com/#feat=css-case-insensitive">Compatibility</a>: at the time of writing no IE present or future :-(</p>

<p><h2 id="pseudo-classes">Pseudo-classes</h2>
Pseudo-classes give information about DOM elements which is not contained in the DOM tree, or is hard to obtain. They start with <code>:</code>, and can be simple attributes or functions that take arguments. They are beasically a random collection of useful CSS stuff.</p>
<p>A lot of changes in Level 4 for these simple selectors.</p>
<h3 id="updated-not-">Updated: not()</h3>
<p class="close-to-next"><code>:not(selector-list)</code> used to take a single simple selector, but it can now take a whole selector list. Lovely idea, but so far only Safari seems interested... (<a href="https://caniuse.com/#feat=css-not-sel-list">Compatibility</a>)</p>

<pre><code>:not(form *) { all selectors that are not inside a form }
button:not([disabled]) { all non disabled buttons }
</code></pre><div class="note"><strong>Dirty hack</strong> incidentally, something like <code>div:not(span)</code> is exactly the same as <code>div</code>, but has more specifity, so it would &quot;win&quot; the specificity war, should that be needed</div>

<h3 id="new-matches-">New: matches()</h3>
<p class="close-to-next"><code>:matches(selector-list)</code> was called :any, (which explains <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:any">the MDN entry for it</a>), so support is a bit confusing (<a href="https://caniuse.com/#feat=css-matches-pseudo">Compatibility</a>)</p>

<p class="close-to-next">It is supposed to do some of the work that SASS and the like do with nesting.</p>

<pre><code>:matches(article, section, div, aside, nav) h1 { ... }

/* instead of: */
article h1,
section h1,
aside h1,
nav h1 { ... }
</code></pre><h3 id="new-has-">New: has()</h3>
<p>A lot of developers have been crying out for this - FINALLY WE CAN CELEBR... oh wait. So far only MS are  <em>considering</em> putting it into a future version of Edge. Maybe. The others are not even touching it with a bargepole. The <a href="https://caniuse.com/#feat=css-has">Compatibility</a> page links to the Mozilla issue dealing with it. It&#39;s from 10 years ago and is currently unassigned...</p>
<p class="close-to-next">For what it&#39;s worth, here is what it <em>would</em> do, if someone bothered to actually implement it:</p>

<pre><code>a:has(&gt; img) { all links with image tags inside them }
section:not(:has(h1, h2)) { all sections with no h1 or h2 inside them}
</code></pre><h3 id="classic-pseudo-classes">Classic pseudo-classes</h3>
<p><code>:link</code> and <code>:visited</code>, those old warhorses, remain unchanged. As does <code>:target</code>, a most useful selector for <abbr title="Single Page Application">SPAs</abbr></p>
<h3 id="minor-pseudo-classes">Minor pseudo-classes</h3>
<p>There are a lot of pseudo-classes in the specs that are not going to be implemented any time soon.</p>
<p><code>:any-link</code> is basically a shortcut for both <code>:link</code> and <code>:visited</code>, and it&#39;s <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:any-link">supported with vendor tags on all browsers except for IE</a>. That, and the fact the documentation has a note &quot;Any better name suggestions for this pseudo?&quot; shows it&#39;s better to leave alone for now.</p>
<p><code>:lang</code> is superior to the <code>|=</code> attribute selector, because the latter only matches elements which have an actual lang attribute, whereas :lang is supposed to be able to work out an element&#39;s lang from its parent. But it&#39;s so badly supported <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:lang">it doesn&#39;t even get a caniuse page</a></p>
<p>The <code>:dir</code> pseudo-class, like :lang, matches element with a given dir whether they have an attribute for it or not. All well and good, but hardly anyone&#39;s implemented it yet - <a href="https://caniuse.com/#feat=css-dir-pseudo">Compatibility</a></p>
<p><code>:current</code>, <code>:past</code>, <code>:future</code> (to do with voice readers), <code>:drop</code>, <code>:drop()</code>, <code>:focus-ring</code> are others</p>

      </div>
    </div>
  </article>


<!-- <section id="comment">
    <h1 class="title">Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
</section>

  </div>
  -->
  <footer id="footer" class="inner">Copyright &copy; 2016

    Fritz Stelluto

</footer>
<!--
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
<script type="text/javascript">
      var disqus_shortname = 'goto-fritz';


        // var disqus_developer = 1;
        var disqus_identifier = 'http://gotofritz.net/blog/geekery/backing-up-hard-disk-os-x/';
        var disqus_url = 'http://gotofritz.net/blog/geekery/backing-up-hard-disk-os-x/';
        var disqus_script = 'embed.js';

    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>
-->


  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-11254155-2']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>

</body>
</html>