
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>Why doesn't ls | echo work? - Fabrizio (Fritz) Stelluto</title>
	<meta name="author" content="">

	
	<meta name="description" content="1
2
$ ls | echo
$ Those new to bash often wonder why piping a command to echo doesn&#8217;t do anything. Here&#8217;s a quick explanation. Streams vs &hellip;">
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="/atom.xml" rel="alternate" title="Fabrizio (Fritz) Stelluto" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.ico" rel="shortcut icon">
	<link rel="icon" href="/favicon.gif" type="image/gif" />
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	
</head>


<body ontouchstart="">

  <header id="header" class="inner">
<nav id="main-nav"><div>
  <a class="rss" href="/atom.xml" title="RSS">RSS</a>
  <a href="/">home</a>
  <a href="/blog/">blog</a>
</div></nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><div>
  <a class="rss" href="/atom.xml" title="RSS">RSS</a>
  <a href="/">home</a>
  <a href="/blog/">blog</a>
</div></div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="http://google.com/search" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:gotofritz.net">
			</form>
		</div>
	</div>
</nav>

<nav id="sub-nav" class="alignright">
	<form class="search" action="http://google.com/search" method="get">
		<input class="alignright" type="text" name="q" results="0">
		<input type="hidden" name="q" value="site:gotofritz.net">
	</form>
</nav>

</header>
	
		
	
	<div id="content" class="inner">
    
    <article class="post">
	<h1 class="title">Why Doesn't Ls | Echo Work?</h1>
	<div>
		<div class="meta">
			<div class="date">








  


<time datetime="2015-05-28T22:58:00+02:00" pubdate data-updated="true">2015-05-28, Thu</time></div>
			<div class="tags">


	<a class='category' href='/blog/cat/geekery/'>Geekery</a>


</div>
			
				<span class="comments"><a href="/blog/geekery/why-pipe-echo-doesnt-work/#disqus_thread">Comments</a></span>
			
		</div>
		<div class="entry-content"><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>ls | <span class="nb">echo</span>
</span><span class='line'><span class="err">$</span>
</span></code></pre></td></tr></table></div></figure>


<p>Those new to bash often wonder why piping a command to <code>echo</code> doesn&#8217;t do anything. Here&#8217;s a quick explanation.</p>

<!--more-->


<h2>Streams vs. Arguments</h2>

<h3>Bash commands are just programs</h3>

<p>Bash commands are small (mostly..) independent programs which in theory <a href="https://en.wikipedia.org/wiki/Unix_philosophy#Do_One_Thing_and_Do_It_Well]">&#8220;do one  thing and do it well&#8221;</a>. To prove this, you can find out where they are in the filesystem with <code>which</code></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>which ls
</span><span class='line'>/usr/local/opt/coreutils/libexec/gnubin/ls
</span><span class='line'><span class="err">$</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Standard Unix streams</h3>

<p>Each of these programs can access <i>streams</i>. Streams are open ended communication channels between the program and the unix core - they used to be the keyboard and the terminal, but they are abstracted so that writing to or reading from a stream is exactly the same as doing it to a file. The &#8220;(text) terminal&#8221; was <em>the</em> way to connect to a computer remotely - it was basically one of those <a href="https://upload.wikimedia.org/wikipedia/commons/8/87/Televideo925Terminal.jpg">fat screens</a> you see in old movies. In modern computers the same functionality is carried out by a small dedicated program, which is referred as either &#8220;the shell&#8221;, &#8220;the command line&#8221;, &#8220;the CLI (command line interface)&#8221; or, on OS X, &#8220;Terminal&#8221;.</p>

<p>The three default streams are STDIN to read from (the keyboard), STDOUT to write to (the shell), and STDERR to write errors to (also the shell). Standard behaviour can be easily changed, so that an app can be made to write to a file instead of the STDOUT stream, for example.</p>

<p>By default your shell app connects the keyboard as STDIN and the shell window as both STDOUT and STDERR. When you type something (STDIN) it&#8217;s passed on immediately to the app which does two things - it pushes it as it is to window (STDOUT) so that you see what you&#8217;ve typed; and it keeps it around waiting for you to hit return. At the point it will parse what you have typed and run it as a command if it can, and print the output to the window (STDOUT); if it doesn&#8217;t understand it, it will print an error message to the window (STDERR)</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c"># Terminal taking your STDIN and copying it to STDOUT</span>
</span><span class='line'><span class="nv">$ </span><span class="nb">echo</span> <span class="s2">&quot;hello&quot;</span>
</span><span class='line'><span class="c"># &lt;RETURN&gt; detected - command run and result printed to STDOUT</span>
</span><span class='line'>hello
</span><span class='line'><span class="c"># this command wasn&#39;t understood - error message printed to STDERR (which</span>
</span><span class='line'><span class="c"># in Terminal is exactly the same window as STDOUT)</span>
</span><span class='line'><span class="nv">$ </span>gibberish
</span><span class='line'>-bash: gibberish: <span class="nb">command </span>not found
</span></code></pre></td></tr></table></div></figure>


<p>A shell program will also get the same STDOUT, STDIN and STDERR as Terminal - depending on the program, you may get the same output twice.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c"># program &quot;cat&quot; recognized and started</span>
</span><span class='line'><span class="nv">$ </span>cat
</span><span class='line'><span class="c"># it just sits there and collects everything you type in STDIN until</span>
</span><span class='line'><span class="c"># you type &lt;RETURN&gt; then it prints it to STDOUT</span>
</span><span class='line'><span class="c"># meanwhile your shell window is also pushing everything it gets to STDOUT,</span>
</span><span class='line'><span class="c"># therefore you get it twice</span>
</span><span class='line'>line1 <span class="c"># printed to STDOUT by shell window as you type</span>
</span><span class='line'>line1 <span class="c"># printed to STDOUT by cat when you typed &lt;RETURN&gt;</span>
</span><span class='line'>line2 <span class="c"># printed to STDOUT by shell window as you type</span>
</span><span class='line'>line2 <span class="c"># etc</span>
</span><span class='line'><span class="c"># to quit the shell program normally you use &lt;CTRL-C&gt;</span>
</span><span class='line'><span class="err">$</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Streams redirection</h3>

<p>You can easily redirect one of the three standard streams to something else - typically a file. To redirect STDOUT, use &gt;</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c"># program cat recognized; STDOUT redirected to a file</span>
</span><span class='line'><span class="nv">$ </span>cat &gt; test.txt
</span><span class='line'><span class="c"># your shell window is still printing to STDOUT as you type; but cat</span>
</span><span class='line'><span class="c"># itself is not, it is printing to the text file.</span>
</span><span class='line'><span class="c"># So this time you only get each line once</span>
</span><span class='line'>line1 <span class="c"># printed to STDOUT by shell window as you type</span>
</span><span class='line'>line2 <span class="c"># printed to STDOUT by shell window as you type</span>
</span><span class='line'><span class="c"># to quit the shell program normally you use &lt;CTRL-C&gt;</span>
</span><span class='line'><span class="err">$</span>
</span><span class='line'><span class="c"># if you open your text file, it will have the text you have just typed inside</span>
</span><span class='line'><span class="nv">$ </span>open test.txt
</span></code></pre></td></tr></table></div></figure>


<p>STDIN is redirected with &lt;</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c"># program cat recognized; instead of taking STDIN from keyboard, use a file</span>
</span><span class='line'><span class="nv">$ </span>cat &lt; test.txt
</span><span class='line'><span class="c"># all the text in the file is printed out in one go</span>
</span><span class='line'>line1
</span><span class='line'>line2
</span><span class='line'>line3
</span></code></pre></td></tr></table></div></figure>


<p>STDERR is redirected with 2&gt;</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c"># error printed to STDERR</span>
</span><span class='line'><span class="nv">$ </span>cat gibberish
</span><span class='line'>cat: gibberish: No such file or directory
</span><span class='line'><span class="c"># STDERR redirected to &quot;the null device&quot;, i.e. an address on Unix systems</span>
</span><span class='line'><span class="c"># that absorbs all error messages and suppresses them</span>
</span><span class='line'><span class="nv">$ </span>cat gibberish 2&gt; /dev/null
</span><span class='line'><span class="c"># no output - it&#39;s disappeared into /dev/null</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Program arguments</h3>

<p>Programs can also have <i>arguments</i> - these are values that are typically typed in and passed to the program by Bash as an array. Arguments are space separated (you can use quotation marks to include a space as part of the argument).</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c"># program &quot;echo&quot; called, and 3 arguments passed to it - a, b, and c</span>
</span><span class='line'><span class="nv">$ </span><span class="nb">echo  </span>a b c
</span><span class='line'><span class="c"># echo does its thing - which is simply to print out arguments</span>
</span><span class='line'>a b c
</span><span class='line'><span class="err">$</span>
</span><span class='line'><span class="c"># this time it echo is called with one argument - the complete sentence</span>
</span><span class='line'><span class="nv">$ </span><span class="nb">echo</span> <span class="s2">&quot;What’s it going to be then, eh?&quot;</span>
</span><span class='line'><span class="c"># in the case of echo, the result looks exactly the same. It may not do for other programs</span>
</span><span class='line'>What’s it going to be <span class="k">then</span>, eh?
</span><span class='line'><span class="err">$</span>
</span></code></pre></td></tr></table></div></figure>


<p>A lot of programs support both arguments and STDIN / STDOUT; but they don&#8217;t have to. Take grep for example - a program that prints out the input if it matches a pattern. When you run it, it looks at how many arguments it was passed to decide what to do:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c"># grep called with two arguments: export and ~/.bash_profile</span>
</span><span class='line'><span class="nv">$ </span>grep <span class="s2">&quot;export&quot;</span> ~/.bash_profile
</span><span class='line'><span class="c"># it runs on the file .bash_profile in your home folder (~/) and prints out each</span>
</span><span class='line'><span class="c"># line that match the pattern</span>
</span><span class='line'><span class="nb">export </span><span class="nv">PATH</span><span class="o">=</span><span class="s2">&quot;$HOME/bin:$PATH&quot;</span>
</span><span class='line'><span class="err">$</span>
</span></code></pre></td></tr></table></div></figure>


<p>When it detects two arguments, it treats the first  as a pattern, and the second as the path of a file to open and read line by line. It then prints any line in the file that include the pattern</p>

<p>But grep also supports STDIN:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c"># grep called with only one argument: export. Instead of connecting to a file,</span>
</span><span class='line'><span class="c"># it waits for input on STDIN</span>
</span><span class='line'><span class="nv">$ </span>grep <span class="s2">&quot;export&quot;</span>
</span><span class='line'><span class="c"># Terminal prints what you type to STDOUT, as usual</span>
</span><span class='line'>I am now typing something
</span><span class='line'><span class="c"># still Terminal...</span>
</span><span class='line'>grep is looking <span class="k">for </span>the string <span class="nb">export</span> - will it find it?
</span><span class='line'><span class="c"># grep has detected &quot;export&quot; in its STDIN - so it prints it to STDOUT</span>
</span><span class='line'>grep is looking <span class="k">for </span>the string <span class="nb">export</span> - will it find it?
</span><span class='line'><span class="err">$</span>
</span></code></pre></td></tr></table></div></figure>


<p>With only one argument, the programmers who created <code>grep</code> decided to treat the first argument as a pattern as before, and to wait for input from STDIN. It makes sense since with only one argument it wouldn&#8217;t know which file to open. In the example above I start typing some random stuff and press return, and when grep finds the string matching the patter in my text it will spit out the string again.</p>

<h3>Streams piping</h3>

<p>What makes Unix so useful is that you can connect small programs together by joining the STDOUT of a program with the STDIN of another - using the pipe character, <code>|</code>, and because streams are treated like files, it will just work. But you already knew that.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c"># the STDOUT of the ps program is connected to the STDIN of grep</span>
</span><span class='line'><span class="nv">$ </span>ps -ef | grep httpd
</span><span class='line'>....
</span><span class='line'><span class="err">$</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Why can&#8217;t you pipe a command to echo?</h2>

<p>With all that out of the way, the explanation is quite simple - piping commands to <code>echo</code> does not work, because echo was not programmed to care about STDIN. All it&#8217;s wired up to do is to take the <i>arguments</i> and copy them to STDOUT.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c"># ls puts the output on STDOUT, which is connected to echo&#39;s STDIN</span>
</span><span class='line'><span class="c"># but echo ignores STDIN, all it cares about is command line arguments</span>
</span><span class='line'><span class="nv">$ </span>ls | <span class="nb">echo</span>
</span><span class='line'><span class="err">$</span>
</span></code></pre></td></tr></table></div></figure>


<p>So if your command ignores STDIN, what you have to do is to find a different one which does the same thing, but also reads from STDIN. In the case of echo, that substitute is <code>cat</code>, which as we saw above, does what echo does, but using STDIN as input:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>ls ~/ | cat
</span><span class='line'>Applications
</span><span class='line'>Desktop
</span><span class='line'>...
</span><span class='line'><span class="err">$</span>
</span></code></pre></td></tr></table></div></figure>


<p>But that&#8217;s not the whole story.</p>

<h2>Using xargs to transform STDIN to arguments</h2>

<p>Turns out you <i>can</i> pipe to echo, if you use <code>xargs</code>. Xargs is a command that takes STDIN and turns it into arguments for a <i>command</i> (if it finds no command it will use echo). So:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c"># xargs is basically creating the command: echo Applications Desktop Documents ...</span>
</span><span class='line'><span class="nv">$ </span>ls ~/ | xargs <span class="nb">echo</span>
</span><span class='line'>Applications Desktop Documents ...
</span><span class='line'><span class="err">$</span>
</span></code></pre></td></tr></table></div></figure>


<p>Notice the difference between <code>cat</code> and <code>xargs</code>. cat adds newlines - it treats each space separated word as a different input. xargs instead removes newlines - part of its purpose is to normalize blank spaces, tabs and newlines into a consistent format.</p>

<p>You can see that better by passing the argument -1 to ls, which prints the arguments one per line:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>ls -1 ~/
</span><span class='line'>Applications
</span><span class='line'>Desktop
</span><span class='line'>...
</span><span class='line'><span class="nv">$ </span> ls -1 ~/ | xargs <span class="nb">echo</span>
</span><span class='line'>Applications Desktop Documents ...
</span></code></pre></td></tr></table></div></figure>


<h2>Further reading</h2>

<p>There is lots of info around the web, here are a couple of simple links:</p>

<ul>
<li><a href="https://gigaom.com/2009/07/01/dig-into-unix-standard-streams/">Dig Into Unix: Standard Streams</a></li>
<li><a href="http://www.westwind.com/reference/OS-X/commandline/pipes.html">Pipes and Redirects</a> and</li>
<li><a href="http://www.december.com/unix/tutor/pipesfilters.html">Intro to Unix: Pipes and Filters</a></li>
</ul>

</div>
	</div>
</article>

<article class="archives">
  <div class="related-posts">
    <h2>Related Posts</h2>
    
      <article>
        <h3 class="title"><a href="/blog/tutorials/copying-files-matching-pattern-cpio">Copying sourcefiles without .svn folders with cpio</a></h3>
        <div class="meta">
          <span class="tags">


	<a class='category' href='/blog/cat/tutorials/'>Tutorials</a>


</span>
            
          <time datetime="2015-05-28T22:58:00+02:00" pubdate>2015-05-28</time>
            
        </div>
      </article>
    
      <article>
        <h3 class="title"><a href="/blog/geekery/os-x-extended-attibutes">Dealing with extended attributes on OS X</a></h3>
        <div class="meta">
          <span class="tags">


	<a class='category' href='/blog/cat/geekery/'>Geekery</a>


</span>
            
          <time datetime="2015-05-28T22:58:00+02:00" pubdate>2015-05-28</time>
            
        </div>
      </article>
    
      <article>
        <h3 class="title"><a href="/blog/howto/a-place-for-unix-scripts-osx">A good place for scripts in OSX</a></h3>
        <div class="meta">
          <span class="tags">


	<a class='category' href='/blog/cat/howto/'>HowTo</a>


</span>
            
          <time datetime="2015-05-28T22:58:00+02:00" pubdate>2015-05-28</time>
            
        </div>
      </article>
    
  </div>
</article>


<section id="comment">
    <h1 class="title">Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
</section>

  </div>
	<footer id="footer" class="inner">Copyright &copy; 2015

    Fabrizio (Fritz) Stelluto

</footer>
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
<script src="/javascripts/slash.js"></script>


<script type="text/javascript">
      var disqus_shortname = 'goto-fritz';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://gotofritz.net/blog/geekery/why-pipe-echo-doesnt-work/';
        var disqus_url = 'http://gotofritz.net/blog/geekery/why-pipe-echo-doesnt-work/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-11254155-2']);
		_gaq.push(['_trackPageview']);

		(function() {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>



</body>
</html>