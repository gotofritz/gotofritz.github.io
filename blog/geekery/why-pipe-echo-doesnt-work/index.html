<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <title>Why doesn&#x27;t ls | echo work? || Fritz Stelluto</title>
  <meta name="author" content="gotofritz">
  <meta name="description" content="&amp;gt; ls | echo
Those new to bash often wonder why piping a command to echo doesn&amp;#39;t do anything. Here&amp;#39;s a quick explanation.">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link href="/assets/favicon.ico" rel="shortcut icon">
  <link rel="icon" href="/assets/favicon.gif" type="image/gif" />
  <link href="/assets/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
</head>

<body ontouchstart="">
  <header id="header" class="inner">
    <nav id="main-nav">
      <div>
        <a href="/">home</a>
        <a href="/blog/">blog</a>
      </div>
    </nav>

    <nav id="sub-nav" class="alignright">
      <form class="search" action="http://google.com/search" method="get">
        <input class="alignright" type="text" name="q" results="0">
        <input type="hidden" name="q" value="site:gotofritz.net">
      </form>
    </nav>
  </header>


<div id="content" class="inner">
  <article class="post">
    <h1 class="title">Why doesn&#x27;t ls | echo work?</h1>
    <div>
      <div class="meta">
        <div class="date">
          <time datetime="2015-05-28T22:58:00+02:00" pubdate>2015-05-28</time>
        </div>
        <div class="tags">
          bash
        </div>
      </div>
      <div class="entry-content">
    
<pre><code>&gt; ls | echo
</code></pre><p>Those new to bash often wonder why piping a command to <code>echo</code> doesn&#39;t do anything. Here&#39;s a quick explanation.
<!--more--></p>
<h2 id="streams-vs-arguments">Streams vs. Arguments</h2>
<h3 id="bash-commands-are-just-programs">Bash commands are just programs</h3>
<p>Bash commands are small (mostly..) independent programs which in theory <a href="https://en.wikipedia.org/wiki/Unix_philosophy#Do_One_Thing_and_Do_It_Well]">&quot;do one  thing and do it well&quot;</a>. To prove this, you can find out where they are in the filesystem with <code>which</code></p>
<pre><code>&gt; which ls
/usr/local/opt/coreutils/libexec/gnubin/ls
</code></pre><p>(but you can&#39;t look inside because they are compiled binaries)</p>
<h3 id="standard-unix-streams">Standard Unix streams</h3>
<p>In the early days of Unix, operators used dumb terminals to connect to the huge, centralised monsters which is what computers were back then. These terminals consisted of a keyboard and a monitor (or printer) and little else - they were basically one of those <a href="https://upload.wikimedia.org/wikipedia/commons/8/87/Televideo925Terminal.jpg">fat screens</a> you see in old movies. The remote computer would happily wait around for all the characters typed by the operator at their own speed, without negative effects if the terminal was too slow in sending characters and without expecting an end. These connections, and the characters traveling on them, were called <i>streams</i>. Streams were then abstracted, so that writing to or reading from a stream is exactly the same as doing it to a file.</p>
<p>In modern computers the same functionality as the terminal is carried out by a small dedicated program, which is referred as either &quot;the shell&quot;, &quot;the command line&quot;, &quot;the CLI (command line interface)&quot; or, on OS X, &quot;Terminal&quot;. The CLI app uses streams to communicate with other parts of the system, like the keyboard or the network.  The three default streams available on Unix terminals are STDIN to read from (the keyboard), STDOUT to write to (the shell), and STDERR to write errors to (also the shell). Standard behaviour can be easily changed, so that an app can be made to write to a file instead of the STDOUT stream, for example. </p>
<p>By default your CLI app connects the keyboard as STDIN and the shell window as both STDOUT and STDERR. When you type something (STDIN) it&#39;s passed on immediately to the app which does two things - it pushes it as it is to window (STDOUT) so that you see what you&#39;ve typed; and it keeps it around waiting for you to hit return. At the point it will parse what you have typed and run it as a command if it can, and print the output to the window (STDOUT); if it doesn&#39;t understand it, it will print an error message to the window (STDERR)</p>
<pre><code># Terminal taking your STDIN and copying it to STDOUT
&gt; echo &quot;hello&quot;
# &lt;RETURN&gt; detected - command run and result printed to STDOUT
hello
# this command wasn&#39;t understood - error message printed to STDERR (which
# in Terminal is exactly the same window as STDOUT)
&gt; gibberish
-bash: gibberish: command not found
</code></pre><p>The bash commends we saw earlier, &#39;ls&#39; or &#39;grep&#39; or &#39;echo&#39;, will also get the same STDOUT, STDIN and STDERR as Terminal - depending on the program, you may get the same output twice.</p>
<pre><code># program &quot;cat&quot; recognized and started
&gt; cat
# it just sits there and collects everything you type in STDIN until
# you type &lt;RETURN&gt; then it prints it to STDOUT
# meanwhile your shell window is also pushing everything it gets to STDOUT,
# therefore you get it twice
line1 # printed to STDOUT by shell window as you type
line1 # printed to STDOUT by cat when you typed &lt;RETURN&gt;
line2 # printed to STDOUT by shell window as you type
line2 # etc
# to quit the shell program normally you use &lt;CTRL-C&gt;
</code></pre><h3 id="streams-redirection">Streams redirection</h3>
<p>You can easily redirect one of the three standard streams to something else - typically a file. To redirect STDOUT, use &gt;</p>
<pre><code># program cat recognized; STDOUT redirected to a file
&gt; cat &gt; test.txt
# your shell window is still printing to STDOUT as you type; but cat
# itself is not, it is printing to the text file.
# So this time you only get each line once
line1 # printed to STDOUT by shell window as you type
line2 # printed to STDOUT by shell window as you type
# to quit the shell program normally you use &lt;CTRL-C&gt;
&gt;
# if you open your text file, it will have the text you have just typed inside
&gt; open test.txt
</code></pre><p>STDIN is redirected with &lt;</p>
<pre><code># program cat recognized; instead of taking STDIN from keyboard, use a file
&gt; cat &lt; test.txt
# all the text in the file is printed out in one go
line1
line2
line3
</code></pre><p>STDERR is redirected with 2&gt;</p>
<pre><code># error printed to STDERR
&gt; cat gibberish
cat: gibberish: No such file or directory
# STDERR redirected to &quot;the null device&quot;, i.e. an address on Unix systems
# that absorbs all error messages and suppresses them
&gt; cat gibberish 2&gt; /dev/null
# no output - it&#39;s disappeared into /dev/null
</code></pre><h3 id="program-arguments">Program arguments</h3>
<p>Programs can also have <i>arguments</i> - these are values that are typically typed in and passed to the program by Bash as an array. Arguments are space separated (you can use quotation marks to include a space as part of the argument).</p>
<pre><code># program &quot;echo&quot; called, and 3 arguments passed to it - a, b, and c
&gt; echo  a b c
# echo does its thing - which is simply to print out arguments
a b c
&gt;
# this time echo is called with one argument - the complete sentence
&gt; echo &quot;What’s it going to be then, eh?&quot;
# in the case of echo, the result looks exactly the same. It may not do for other programs
What’s it going to be then, eh?
&gt;
</code></pre><p>A lot of programs support both arguments and STDIN / STDOUT; but they don&#39;t have to. Take grep for example - a program that prints out the input if it matches a pattern. When you run it, it looks at how many arguments it was passed to decide what to do:</p>
<pre><code># grep called with two arguments: export and ~/.bash_profile
&gt; grep &quot;export&quot; ~/.bash_profile
# it runs on the file .bash_profile in your home folder (~/) and prints out each
# line that matches the pattern
export PATH=&quot;$HOME/bin:$PATH&quot;
</code></pre><p>When it detects two arguments, it treats the first  as a pattern, and the second as the path of a file to open and read line by line. It then prints any line in the file that include the pattern</p>
<p>But grep also supports STDIN:</p>
<pre><code># grep called with only one argument: export. Instead of connecting to a file,
# it waits for input on STDIN
&gt; grep &quot;export&quot;
# Terminal prints what you type to STDOUT, as usual
I am now typing something
# still Terminal...
grep is looking for the string export - will it find it?
# grep has detected &quot;export&quot; in its STDIN - so it prints it to STDOUT
grep is looking for the string export - will it find it?
</code></pre><p>With only one argument, the programmers who created <code>grep</code> decided to treat the first argument as a pattern as before, and to wait for input from STDIN. It makes sense since with only one argument it wouldn&#39;t know which file to open. In the example above I start typing some random stuff and press return, and when grep finds the string matching the patter in my text it will spit out the string again.</p>
<h3 id="streams-piping">Streams piping</h3>
<p>What makes Unix so useful is that you can connect small programs together by joining the STDOUT of a program with the STDIN of another - using the pipe character, <code>|</code>, and because streams are treated like files, it will just work. But you already knew that.</p>
<pre><code># the STDOUT of the ps program is connected to the STDIN of grep
&gt; ps -ef | grep httpd
....
</code></pre><h2 id="why-can-t-you-pipe-a-command-to-echo-">Why can&#39;t you pipe a command to echo?</h2>
<p>With all that out of the way, the explanation is quite simple - piping commands to <code>echo</code> does not work, because echo was not programmed to care about STDIN. All it&#39;s wired up to do is to take the <i>arguments</i> and copy them to STDOUT.</p>
<pre><code># ls puts the output on STDOUT, which is connected to echo&#39;s STDIN
# but echo ignores STDIN, all it cares about is command line arguments
&gt; ls | echo
</code></pre><p>So if your command ignores STDIN, what you have to do is to find a different one which does the same thing, but also reads from STDIN. In the case of echo, that substitute is <code>cat</code>, which as we saw above, does what echo does, but using STDIN as input:</p>
<pre><code>&gt; ls ~/ | cat
Applications
Desktop
...
</code></pre><p>But that&#39;s not the whole story.</p>
<h2 id="using-xargs-to-transform-stdin-to-arguments">Using xargs to transform STDIN to arguments</h2>
<p>Turns out you <i>can</i> pipe to echo, if you use <code>xargs</code>. Xargs is a command that takes STDIN and turns it into arguments for a <i>command</i> (if it finds no command it will use echo). So:</p>
<pre><code># xargs is basically creating the command: echo Applications Desktop Documents ...
&gt; ls ~/ | xargs echo
Applications Desktop Documents ...
</code></pre><p>Notice the difference between <code>cat</code> and <code>xargs</code>. cat adds newlines - it treats each space separated word as a different input. xargs instead removes newlines - part of its purpose is to normalize blank spaces, tabs and newlines into a consistent format.</p>
<p>You can see that better by passing the argument -1 to ls, which prints the arguments one per line:</p>
<pre><code>&gt; ls -1 ~/
Applications
Desktop
...
&gt;  ls -1 ~/ | xargs echo
Applications Desktop Documents ...
</code></pre><h2 id="further-reading">Further reading</h2>
<p>There is lots of info around the web, here are a couple of simple links:</p>
<ul>
<li><a href="https://gigaom.com/2009/07/01/dig-into-unix-standard-streams/">Dig Into Unix: Standard Streams</a></li>
<li><a href="http://www.westwind.com/reference/OS-X/commandline/pipes.html">Pipes and Redirects</a> and</li>
<li><a href="http://www.december.com/unix/tutor/pipesfilters.html">Intro to Unix: Pipes and Filters</a></li>
</ul>

      </div>
    </div>
  </article>


<!-- <section id="comment">
    <h1 class="title">Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
</section>

  </div>
  -->
  <footer id="footer" class="inner">Copyright &copy; 2016

    Fritz Stelluto

</footer>
<!--
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
<script type="text/javascript">
      var disqus_shortname = 'goto-fritz';


        // var disqus_developer = 1;
        var disqus_identifier = 'http://gotofritz.net/blog/geekery/backing-up-hard-disk-os-x/';
        var disqus_url = 'http://gotofritz.net/blog/geekery/backing-up-hard-disk-os-x/';
        var disqus_script = 'embed.js';

    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>
-->


  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-11254155-2']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>

</body>
</html>