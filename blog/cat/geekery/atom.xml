<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Geekery | Fabrizio (Fritz) Stelluto]]></title>
  <link href="http://gotofritz.net/blog/cat/geekery/atom.xml" rel="self"/>
  <link href="http://gotofritz.net/"/>
  <updated>2015-07-15T01:35:42+02:00</updated>
  <id>http://gotofritz.net/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How to prevent Less errors stopping gulp watch]]></title>
    <link href="http://gotofritz.net/blog/geekery/how-to-prevent-less-errors-stopping-gulp-watch/"/>
    <updated>2015-06-19T00:56:00+02:00</updated>
    <id>http://gotofritz.net/blog/geekery/how-to-prevent-less-errors-stopping-gulp-watch</id>
    <content type="html"><![CDATA[<p>A <code>gulp watch</code> task will stop as soon as you have a Less error. Here's I how prevented that.</p>

<!--more-->


<h2>A simple gulp less task</h2>

<p>Here is a simple gulp less task that runs manually by typing <code>gulp css:less</code>:
``` js
var less = require("gulp-less");</p>

<p>gulp.task(“css:less", function (cb) {
   var lessArgs = {</p>

<pre><code>      // fill in as appropriate
    };
</code></pre>

<p>   return gulp
  .src(“./less/<em>*/</em>.less")
  .pipe(less(lessArgs))
  .pipe(gulp.dest("dist/"));
});
```</p>

<h2>A simple "gulp watch" task</h2>

<p>Here is a simple watch version of the task - it will watch less files, and rerun the task whenever a file is changed:
``` js
var less = require("gulp-less");
var watch = require("gulp-watch");</p>

<p>gulp.task("css:watch", function (cb) {
  var lessArgs = {</p>

<pre><code>  // fill in as appropriate
};
</code></pre>

<p>  return gulp
  .src(“./less/<strong>/*.less")
  .pipe(watch(“./less/</strong>/*.less"))
  .pipe(less(lessArgs))
  .pipe(gulp.dest("dist/"));
});
```</p>

<h2>The gulp-less plugin documentation doesn’t help</h2>

<p>The <a href="https://www.npmjs.com/package/gulp-less">gulp-less plugin documentation</a> states</p>

<blockquote><p>By default, a gulp task will fail and all streams will halt when an error happens.To change this behavior check out the error handling documentation <a href="https://github.com/gulpjs/gulp/blob/master/docs/recipes/combining-streams-to-handle-errors.md">here</a></p></blockquote>

<p>But don’t waste your time installing the <code>stream-combiner2</code> plugin - it doesn’t work.</p>

<p><code>Plumber</code>, which  I came across when googling for the issue (you’ll probably end up <a href="https://github.com/gulpjs/gulp/issues/259">in this github issue</a>  sooner or later if you google for this) didn't help either.</p>

<h2>How to stop "gulp watch" dying when on a Less or Sass error</h2>

<p>The solution that worked for me was to create a function which handles the error and make the function emit the error. Then attach directly to the less task:
``` js
var gutil = require("gulp-util");
var less = require("gulp-less");
var onError = function (err) {</p>

<pre><code>gutil.log(gutil.colors.red("ERROR", taskName), err);
this.emit("end", new gutil.PluginError(taskName, err, { showStack: true }));
</code></pre>

<p>  };</p>

<p>gulp.task(“css:less", function jsLint() {
  var lessArgs = {</p>

<pre><code>  // fill in as appropriate
};
</code></pre>

<p>  return gulp
  .src(“./less/<strong>/*.less")
  .pipe(watch(“./less/</strong>/*.less"))
  .pipe(less(lessArgs).on('error', onError))
  .pipe(gulp.dest("dist/"));
});
<code>``
In the example above, the function is</code>onError<code>- is the “this.emit” that does the magic.</code>gutil.log<code>is only eye candy. The onError function is connected to less with</code>.on(“error”, onError)`. And that’s all there is to it.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Why doesn't ls | echo work?]]></title>
    <link href="http://gotofritz.net/blog/geekery/why-pipe-echo-doesnt-work/"/>
    <updated>2015-05-28T22:58:00+02:00</updated>
    <id>http://gotofritz.net/blog/geekery/why-pipe-echo-doesnt-work</id>
    <content type="html"><![CDATA[<p><code>bash
$ ls | echo
$
</code>
Those new to bash often wonder why piping a command to <code>echo</code> doesn't do anything. Here's a quick explanation.</p>

<!--more-->


<h2>Streams vs. Arguments</h2>

<h3>Bash commands are just programs</h3>

<p>Bash commands are small (mostly..) independent programs which in theory <a href="https://en.wikipedia.org/wiki/Unix_philosophy#Do_One_Thing_and_Do_It_Well]">"do one  thing and do it well"</a>. To prove this, you can find out where they are in the filesystem with <code>which</code>
<code>bash
$ which ls
/usr/local/opt/coreutils/libexec/gnubin/ls
$
</code></p>

<h3>Standard Unix streams</h3>

<p>Each of this programs can access <i>streams</i>. Streams are open ended communication channels between the program and the environment - they used to be the keyboard and the terminal, but they are abstracted so that writing to or reading from a stream is exactly the same as doing it to a file. The three default streams are STDIN to read from (the keyboard), STDOUT to write to (the terminal), and STDERR to write errors to (also the terminal). Standard behaviour can be easily changed, so that an app can be made to write to a file instead of the STDOUT stream, for example.</p>

<p>By default your shell app (Terminal on OS X) connects the keyboard as STDIN and the shell window as both STDOUT and STDERR. When you type something (STDIN) it's passed on immediately to the app which does two things - it pushes it as it is to window (STDOUT) so that you see what you've typed; and it keeps it around waiting for you to hit return. At the point it will parse what you have typed and run it as a command if it can, and print the output to the window (STDOUT); if it doesn't understand it, it will print an error message to the window (STDERR)</p>

<p>``` bash</p>

<h1>Terminal taking your STDIN and copying it to STDOUT</h1>

<p>$ echo "hello"</p>

<h1><RETURN> detected - command run and result printed to STDOUT</h1>

<p>hello</p>

<h1>this command wasn't understood - error message printed to STDERR (which in Terminal is exactly the same window as STDOUT)</h1>

<p>$ gibberish
-bash: gibberish: command not found
```</p>

<p>A shell program will also get the same STDOUT, STDIN and STDERR as Terminal - depending on the program, you may get the same output twice.
``` bash</p>

<h1>program "cat" recognized and started</h1>

<p>$ cat</p>

<h1>it just sits there and collects everything you type in STDIN until you type <RETURN> then it prints it to STDOUT</h1>

<h1>meanwhile your shell window is also pushing everything it gets to STDOUT, therefore you get it twice</h1>

<p>line1 # printed to STDOUT by shell window as you type
line1 # printed to STDOUT by cat when you typed <RETURN>
line2 # printed to STDOUT by shell window as you type
line2 # etc</p>

<h1>to quit the shell program normally you use <CTRL-C></h1>

<p>$
```</p>

<h3>Streams redirection</h3>

<p>You can easily redirect one of the three standard streams to something else - typically a file. To redirect STDOUT, use &gt;
``` bash</p>

<h1>program cat recognized; STDOUT redirected to a file</h1>

<p>$ cat > test.txt</p>

<h1>your shell window is still printing to STDOUT as you type; but cat itself is not, it is printing to the text file.</h1>

<h1>So this time you only get each line once</h1>

<p>line1 # printed to STDOUT by shell window as you type
line2 # printed to STDOUT by shell window as you type</p>

<h1>to quit the shell program normally you use <CTRL-C></h1>

<p>$</p>

<h1>if you open your text file, it will have the text you have just typed inside</h1>

<p>$ open test.txt
```</p>

<p>STDIN is redirected with &lt;
``` bash</p>

<h1>program cat recognized; instead of taking STDIN from keyboard, use a file</h1>

<p>$ cat &lt; test.txt</p>

<h1>all the text in the file is printed out in one go</h1>

<p>line1
line2
line3
```</p>

<p>STDERR is redirected with 2&gt;
``` bash</p>

<h1>error printed to STDERR</h1>

<p>$ cat gibberish
cat: gibberish: No such file or directory</p>

<h1>STDERR redirected to "the null device", i.e. an address on Unix systems that absorbs all error messages and suppresses them</h1>

<p>$ cat gibberish 2> /dev/null</p>

<h1>no output - it's disappeared into /dev/null</h1>

<p>```</p>

<h3>Streams piping</h3>

<p>What makes Unix so useful is that you can connect small programs together by joining the STDOUT of a program with the STDIN of another - using the pipe character, <code>|</code>, and because streams are treated like files, it will just work. But you already knew that.
``` bash</p>

<h1>the STDOUT of the ps program is connected to the STDIN of grep</h1>

<p>$ ps -ef | grep httpd
....
$
```</p>

<h3>Program arguments</h3>

<p>Programs can also have <i>arguments</i> - these are values that are typically typed in and passed to the program by Bash as an array. A lot of programs support both arguments and STDIN / STDOUT; but they don't have to. So, grep for example loads its arguments to decide what to do:
<code>bash
$ grep "export" ~/.bash_profile
export PATH="$HOME/bin:$PATH"
$
</code>
In this case the first argument is a pattern to match, and the second a filename. <code>grep</code> finds occurrences of the pattern in the file.</p>

<p>But grep also supports STDIN:
<code>bash
$ grep "export"
I am now typing something
grep is looking for the string export - will it find it?
grep is looking for the string export - will it find it?
$
</code>
With only one argument, the programmer(s) who created <code>grep</code> decided to treat the first argument as a pattern as before, and to wait for input from STDIN since it wouldn't know which file to open. In the example above I start typing some random stuff and press return, and when grep finds the string matching the patter in my text it will spit out the string again.</p>

<h2>Why can't you pipe a command to echo?</h2>

<p>With all that out of the way, the explanation is quite simple - piping commands to <code>echo</code> does not work, because echo was not programmed to care about STDIN. All it's wired up to do is to take the <i>arguments</i> and copy them to STDOUT.
``` bash</p>

<h1>ls puts the output on STDOUT, which is connected to echo's STDIN</h1>

<h1>but echo ignores STDIN, all it cares about is command line arguments</h1>

<p>$ ls | echo
$</p>

<h1>takes arguments 1 2 3 and copies them to STDOUT</h1>

<p>$ echo 1 2 3
1 2 3
$
<code>
So if your command ignores STDIN, what you have to do is to find a different one which does the same thing, but also reads from STDIN. In the case of echo, that substitute is `cat`, which as we saw above, does what echo does, but using STDIN as input:
</code>
$ ls ~/ | cat
Applications
Desktop
...
$
```
But that's not the whole story.</p>

<h2>Using xargs to transform STDIN to arguments</h2>

<p>Turns out you <i>can</i> pipe to echo, if you use <code>xargs</code>. Xargs is a command that takes STDIN and turns it into arguments for a <i>command</i> (if it finds no command it will use echo). So:
``` bash</p>

<h1>xargs is basically creating the command: echo Applications Desktop Documents ...</h1>

<p>$ ls ~/ | xargs echo
Applications Desktop Documents ...
$
<code>``
Notice the difference between</code>cat<code>and</code>xargs`. cat adds newlines - it treats each space separated word as a different input. xargs instead removes newlines - part of its purpose is to normalize blank spaces, tabs and newlines into a consistent format.</p>

<p>You can see that better by passing the argument -1 to ls, which prints the arguments one per line:
<code>bash
$ ls -1 ~/
Applications
Desktop
...
$  ls -1 ~/ | xargs echo
Applications Desktop Documents ...
</code></p>

<h2>Further reading</h2>

<p>There is lots of info around the web, here are a couple of simple links:
<a href="https://gigaom.com/2009/07/01/dig-into-unix-standard-streams/">Dig Into Unix: Standard Streams</a>
<a href="http://www.westwind.com/reference/OS-X/commandline/pipes.html">Pipes and Redirects</a> and
<a href="http://www.december.com/unix/tutor/pipesfilters.html">Intro to Unix: Pipes and Filters</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to generate an error in a Gulp task]]></title>
    <link href="http://gotofritz.net/blog/geekery/how-to-generate-error-in-gulp-task/"/>
    <updated>2015-04-27T12:29:00+02:00</updated>
    <id>http://gotofritz.net/blog/geekery/how-to-generate-an-error-in-a-gulp-task</id>
    <content type="html"><![CDATA[<p>When writing a Gulp task that doesn't involve streams, how do you throw an error?</p>

<!--more-->


<h2>Motivation</h2>

<p><a href="http://gulpjs.com/">Gulp</a>, is a popular javscript build tool for web development. Gulp tasks are based around <a href="https://github.com/substack/stream-handbook">streams</a>; but sometimes streams are too clumsy when you want to do a simple task. Say you want to check a JSON file conforms to certain rule. It's much easier to require the file, check what you need to check, and then throw an error if you need to than it is opening the file as a stream and validating it.</p>

<p>But how do you throw an error in Gulp "the proper way", i.e. not just by throwing a standard JS error?</p>

<h2>Validating a package.json file</h2>

<p>I had to validate a package json file to make sure all packages were installed with the <code>--save-dev</code> flag. In other words, all dependencies should be in exact semantic format, <code>1.2.3</code> instead of the default <code>^1.2.3</code> or <code>~1.2.3</code>. It is simply enough in plain node, without the extra complication of streams - you require package.json, then test each dependency.</p>

<p>``` js
gulp.task(taskName, function (cb) {
  var gutil = require("gulp-util");
  var packageData = require("./package.json");</p>

<p>  // we test all three types of dependencies
  ["devDependencies", "dependencies", "optionalDependencies"]
  .forEach(function validateAnObj(key) {</p>

<pre><code>// load each dependency
Object.keys(packageData[key])
.forEach(function validateAField(field) {

  // check the version complies
  var hasInvalidVersion = (/[^0-9.]/.test(packageData[key][field]));

  // this is where the magic happens
  if (hasInvalidVersion) {
    throw new gutil.PluginError({
      plugin: taskName,
      message: field + " in " + key + " has non compliant versioning: " + packageData[key][field]
    });
  }
});
</code></pre>

<p>  });
});
```</p>

<h2>Throwing an error with gulp</h2>

<p>The easiset way to throw a gulp-y error is to use <code>gulp-util</code>, which has a PluginError that can be thrown. <a href="https://github.com/gulpjs/gulp-util#user-content-new-pluginerrorpluginname-message-options">Here is the documentation for PluginError</a>. <code>plugin</code> and <code>message</code> get outputted on separate lines; they are basically a title message and a message body.
There are also a couple of options that can be passed, do refer to the documentation.</p>

<h2>This is not using gulp the way it was meant to be</h2>

<p>There isn't always a benefit in turning simple problems into a stream problem. Hope this info was useful.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OS X DNS lookups too slow for local hosts]]></title>
    <link href="http://gotofritz.net/blog/geekery/os-x-dns-lookups-too-slow-for-local-hosts/"/>
    <updated>2015-04-24T13:03:00+02:00</updated>
    <id>http://gotofritz.net/blog/geekery/os-x-dns-lookups-too-slow-for-local-hosts</id>
    <content type="html"><![CDATA[<p>I have several local hosts set up on my dev OS X machine. The browser hangs for several seconds while trying to load them. Which doesn't make any sense, since they are local.</p>

<!--more-->


<p>The solution is to change the <code>/etc/hosts</code> file so that all hosts are on one line, the very first line where localhost is defined.</p>

<p>In other words, change from this...
<code>bash
127.0.0.1       localhost
255.255.255.255 broadcasthost
::1             localhost
fe80::1%lo0     localhost
127.0.0.1       my-host.dev
127.0.0.1       another-host.dev
127.0.0.1       oh-that-host.dev
</code></p>

<p>...to this.
<code>bash
127.0.0.1       localhost  my-host.dev another-host.dev oh-that-host.dev
255.255.255.255 broadcasthost
::1             localhost
fe80::1%lo0     localhost
</code></p>

<p>It <em>still</em> doesn't make sense, but it works and that's all that matters.</p>

<p><small>Answer from <a href="http://stackoverflow.com/questions/10064581/how-can-i-eliminate-slow-resolving-loading-of-localhost-virtualhost-a-2-3-secon">Stack Overflow</a></small></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Useful Alfred workflows for web development]]></title>
    <link href="http://gotofritz.net/blog/geekery/alfred-workflows-web-development/"/>
    <updated>2015-04-04T01:51:00+02:00</updated>
    <id>http://gotofritz.net/blog/geekery/useful-alfred-color-tool-for-os-x</id>
    <content type="html"><![CDATA[<p><a href="http://www.alfredapp.com/">Alfred App</a> has a couple of useful workflow for web developers.</p>

<!--more-->


<p>Alfred App is one of the things that make working on OS X a pleasure. There are lots of useful workflows out there, and using a folder inside Dropbox as the sync folder (Preferences &gt; Advanced &gt; Syncing.. ) allows me to share them among my work and home machines.</p>

<p>Here are a couple of workflows I find useful for web development.</p>

<h2><a href="http://www.packal.org/workflow/colors">Colors</a></h2>

<p>I can type a color directly into Alfred, say <code>#ff0000</code> or <code>rgb 1,45,87</code> and Alfred will show me a list of conversions in other formats, with a swatch in the color itself. Use <code>c name</code> for a CSS color name, say <code>c red</code>.</p>

<h2><a href="https://github.com/willfarrell/alfred-encode-decode-workflow">Encode/Decode</a></h2>

<p>Quickly convert from HTML or URL encoded text to plain by typing <code>decode &lt;TEXT&gt;</code>, or viceversa with  <code>encode &lt;TEXT&gt;</code>.</p>
]]></content>
  </entry>
  
</feed>
