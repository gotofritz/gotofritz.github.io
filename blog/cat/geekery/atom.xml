<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Geekery | Fabrizio (Fritz) Stelluto]]></title>
  <link href="http://gotofritz.net/blog/cat/geekery/atom.xml" rel="self"/>
  <link href="http://gotofritz.net/"/>
  <updated>2015-11-22T02:18:25+01:00</updated>
  <id>http://gotofritz.net/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Pretty printing XML]]></title>
    <link href="http://gotofritz.net/blog/geekery/pretty-printing-xml/"/>
    <updated>2015-10-21T00:38:00+02:00</updated>
    <id>http://gotofritz.net/blog/geekery/pretty-printing-xml</id>
    <content type="html"><![CDATA[<p><a href="http://www.w3.org/People/Raggett/tidy/">tidy</a> is a command line tool to pretty print XML.</p>

<!--more-->


<h2>What is tidy?</h2>

<p>It's a very unslick util for tidying up HTML markup which gets the job done. It also has an XML mode, which is what is useful here. To install it on OS X, simply do
``` bash</p>

<blockquote><p>brew install tidy
```</p></blockquote>

<h2>Tidy usage</h2>

<p>To pretty print <code>input.xml</code>  and save the output to <code>pretty_printed.xml</code></p>

<p>``` bash</p>

<blockquote><p>tidy -xml -i input.xml > pretty_printed.xml
```</p></blockquote>

<p>There are several <a href="http://tidy.sourceforge.net/docs/quickref.html#break-before-br">command line options</a>. For example, to change the case of tabs to uppercase:</p>

<p>``` bash</p>

<blockquote><p>tidy -xml --uppercase-tags y  -i input.xml
```</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Multiline regular expressions in Javascript]]></title>
    <link href="http://gotofritz.net/blog/geekery/multiline-regular-expressions-javascript/"/>
    <updated>2015-09-19T23:39:00+02:00</updated>
    <id>http://gotofritz.net/blog/geekery/multiline-regular-expressions-in-javascript</id>
    <content type="html"><![CDATA[<p>There are no flags to match multi-line text is in JS. But it can be done with a character class.</p>

<!--more-->


<h2>The problem</h2>

<p>In both cases below we expect <code>\d.line</code> to match <code>0\nline</code> but it doesn't work - because newlines are not matched by the <code>.</code> character class.
```js
"line 0\nline1".match(/\d.line/)
// null</p>

<p>// ES6
<code>line 0
line1</code>.match(/\d.line/)
// null
```</p>

<h2>The solution</h2>

<p>Use the <code>[^]</code> character class, which is equivalent to <code>.</code> but with the newline added in
```js
"line 0\nline1".match(/\d[<sup>]line/)</sup>
// ["0
// line"]</p>

<p>// ES6
<code>line 0
line1</code>.match(/\d[<sup>]line/)</sup>
// ["0
// line"]
```</p>

<p>For more info, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#character-classes">visit the relevant MDN page</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OS X Software Update from the Command Line]]></title>
    <link href="http://gotofritz.net/blog/geekery/os-x-software-update-from-command-line/"/>
    <updated>2015-08-25T00:41:00+02:00</updated>
    <id>http://gotofritz.net/blog/geekery/os-x-software-update-from-the-command-line</id>
    <content type="html"><![CDATA[<p>Software updates can be quite tedious - you have to click a lot of buttons, then get into the Apple Store etc. But you can avoid all that by running it from the command line.</p>

<!--more-->


<p>``` bash
$ sudo softwareupdate -i -r
Password:
Software Update Tool
Copyright 2002-2012 Apple Inc.</p>

<p>Finding available software</p>

<p>Downloaded OS X Update
Installing OS X Update
Done.
```</p>

<p>Which breaks down as</p>

<dl class="code-breakdown">
  <dt>sudo</dt>
  <dd>needs to run as admin (you will have to enter a password after you type return)</dd>

  <dt>softwareupdate</dt>
  <dd>this is the command line utility that does the job</dd>

  <dt>-i</dt>
  <dd>install - you can specify what to install, all, or just...</dd>

  <dt>-r</dt>
  <dd>...the recommended updates</dd>
</dl>


<p>This is all there is to it.</p>

<h2>Slightly more complex usage of softwareupdate</h2>

<p>You can ask for a list of available software before you install:
```  bash
$ softwareupdate -l
Software Update Tool
Copyright 2002-2012 Apple Inc.</p>

<p>Finding available software
Software Update found the following new or updated software:
  * MacBookAirEFIUpdate2.4-2.4</p>

<pre><code>   MacBook Air EFI Firmware Update (2.4), 3817K [recommended] [restart]
</code></pre>

<ul>
<li>ProAppsQTCodecs-1.0
   ProApps QuickTime codecs (1.0), 968K [recommended]</li>
<li>JavaForOSX-1.0
   Java for OS X 2012-005 (1.0), 65288K [recommended]
```</li>
</ul>


<p>You can then install individual packages by simply naming them
<code>bash
$ sudo softwareupdate -i JavaForOSX-1.0
</code></p>

<p>Or you can ignore some packages and then install everything else (<code>-a, all</code>)
<code>bash
$ softwareupdate --ignore JavaForOSX-1.0
$ sudo softwareupdate -i -a
</code></p>

<p>Note that the --ignore flag will persist until it is reset with <code>--reset-ignored</code> (which clears <em>all</em> flags)
<code>bash
$ softwareupdate --reset-ignored
</code></p>

<p>More options can be viewed with <code>softwareupdate -h</code> or <code>man softwareupdate</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A selection of akw scripts]]></title>
    <link href="http://gotofritz.net/blog/geekery/a-selection-of-akw-scripts/"/>
    <updated>2015-07-25T00:16:00+02:00</updated>
    <id>http://gotofritz.net/blog/geekery/a-selection-of-akw-scripts</id>
    <content type="html"><![CDATA[<p>Some examples scripts to complement the previous <a href="/blog/geekery/back-to-the-classics-awk/">awk tutorial</a></p>

<!--more-->


<p>All the scripts here assume the fields in the data is space separated - i.e. <code>UK   London  10000</code> etc. There hasn't been a CSV standard until recently, but the one you get from MS Office doesn't work too well with awk, because CSV is basically a rubbish format and hard to handle. But if you have a "well behaved" CSV file, i.e. one which doesn't have commas, quotation marks, or new lines inside fields, e.g <code>UK,London,10000</code> then you can easily process it by passing -F"," to the awk call:
<code>bash
awk -F"," -f my_awk_script.awk some_input_data.txt
</code>
In practice unless you generate the data yourself there is always going to be the odd comma or quotation mark in your data somewhere, so I find it easier to convert the data to tab separated using a <a href="http://www.convertcsv.com/csv-to-csv.htm">free online CSV to TSV converter like this</a>. I then call awk with "\t" as the separator, because some field may have spaces inside them.</p>

<p>The command below is what I use - my awk program is in my_awk_script.awk, the data is in uk_electoral_data_converted.csv, and the results goes into awk_output.txt.
<code>
awk -F"\t" -f my_awk_script.awk uk_electoral_data_converted.csv &gt; awk_output.txt
</code></p>

<h3>Sample data: UK election results</h3>

<p>Some of the scripts will use <a href="http://is.gd/eUrbOZ">data from the 2015 UK election in CSV format</a> as data, converted to TSV. Here's what it looks like:
<code>bash
Forename  Surname Description on ballot paper Constituency Name PANO  Votes Share (%) Change  FIELD9  Incumbent?  FIELD11 Constituency ID Region ID County  Region  Country Constituency type Party name identifier Party abbreviation
Gerald  Howarth The Conservative Party Candidate  Aldershot 7 23369 50.6  3.9   MP    E14000530 E12000008 Hampshire South East  England Borough Conservative  Con
Gary  Puffett Labour Party  Aldershot 7 8468  18.3  6.2       E14000530 E12000008 Hampshire South East  England Borough Labour  Lab
Bill  Walker  UK Independence Party (UKIP)  Aldershot 7 8253  17.9  13.4        E14000530 E12000008 Hampshire South East  England Borough UK Independence Party UKIP
...
</code></p>

<p>And here are the field names in order
<code>bash
 1 Forename
 2 Surname
 3 Description on ballot paper
 4 Constituency Name
 5 PANO
 6 Votes
 7 Share (%)
 8 Change
 9 --
10 Incumbent?
11 --
12 Constituency ID
13 Region ID
14 County
15 Region
16 Country
17 Constituency type
18 Party name identifier
19 Party abbreviation
</code></p>

<h3>Skipping header row</h3>

<p>``` bash</p>

<h1>put NR > 1 in front of every action to skip the header row</h1>

<p>NR > 1 { print }</p>

<h1>result</h1>

<p>Gerald  Howarth The Conservative Party Candidate  Aldershot ...
...
```</p>

<h3>Skipping empty records</h3>

<p>``` bash</p>

<h1>check if the first field is empty</h1>

<p>NF { print }
```</p>

<h3>Rearranging fields, and skipping some</h3>

<p>``` bash
NR > 1 &amp;&amp; NF { print $4 ": " $2 " " $1 " (" $NF ") " $7 "% " }</p>

<h1>NR > 1    ignore header</h1>

<h1>NF  ignore empty record</h1>

<h1>print constituence name, name surname, party abbreviation, share of the vote</h1>

<h1>ignore otehr fields</h1>

<p>Aldershot: Howarth Gerald (Con) 50.6%
Aldershot: Puffett Gary (Lab) 18.3%
Aldershot: Walker Bill (UKIP) 17.9%
Aldershot: Hilliar Alan (LD) 8.8%
Aldershot: Hewitt Carl (Green) 4.4%
...
```</p>

<h3>Print sum of all fields</h3>

<p>Finds the national Conservative vote
``` bash
$NF == "Con" {total += $6}
END          {print total}</p>

<h1>$NF == "Con"  if a record concerns a tory vote</h1>

<h1>{total += $6} add it to a running total</h1>

<h1>END           when all records are processed</h1>

<h1>{print total} output total</h1>

<p>11299609
```</p>

<h3>Work out column averages</h3>

<p>Find the total vote of the 6 larger parties and their % of the national vote
``` bash</p>

<h1>keep a running total</h1>

<p>NR > 1 &amp;&amp; NF  {total += $6}</p>

<h1>keep a total for each party - don' do anything yet</h1>

<p>$NF == "Con"        {total_con += $6}
$NF == "Lab"        {total_lab += $6}
$NF == "UKIP"       {total_ukip += $6}
$NF == "LD"         {total_ld += $6}
$NF == "Green"      {total_green += $6}
$NF == "SNP"        {total_snp += $6}</p>

<h1>print a report at the end</h1>

<p>END {
  print "TOTAL: " total
  print "Con:   " (100 * total_con / total) "%"
  print "Lab:   " (100 * total_lab / total) "%"
  print "UKIP:  " (100 * total_ukip / total) "%"
  print "LD:    " (100 * total_ld / total) "%"
  print "SNP:   " (100 * total_snp / total) "%"
  print "Green: " (100 * total_green / total) "%"
}</p>

<h1>output:</h1>

<p>TOTAL: 30697255
Con:   36.8098%
Lab:   30.449%
UKIP:  12.6431%
LD:    7.87014%
SNP:   4.738%
Green: 3.77112%
```</p>

<h3>Using functions</h3>

<p>The same as above, but without copy and paste code
``` bash</p>

<h1>abstracting copy-and-paste code into a function</h1>

<p>function print_party_percentage(party_name, party_vote, total_vote) {
  print party_name "   " (100 * party_vote / total_vote) "%"
}</p>

<h1>same program as before</h1>

<p>NR > 1 &amp;&amp; NF   {total += $6}
$NF == "Con"   {total_con += $6}
$NF == "Lab"   {total_lab += $6}
$NF == "UKIP"  {total_ukip += $6}
$NF == "LD"    {total_ld += $6}
$NF == "Green" {total_green += $6}
$NF == "SNP"   {total_snp += $6}
END {
  print "TOTAL: " total
  print_party_percentage("Con", total_con, total)
  print_party_percentage("Lab", total_lab, total)
  print_party_percentage("UKIP", total_ukip, total)
  print_party_percentage("LD", total_ld, total)
  print_party_percentage("SNP", total_snp, total)
  print_party_percentage("Green", total_green, total)
}</p>

<h1>output - looks messier because previous program was manually formatted</h1>

<p>TOTAL: 30697255
Con   36.8098%
Lab   30.449%
UKIP   12.6431%
LD   7.87014%
SNP   4.738%
Green   3.77112%
```</p>

<h3>Formatting numerical precision and alignment with printf</h3>

<p>Same as above, but using printf for formatting
``` bash
function print_party_percentage(party_name, party_vote, total_vote) {
  printf "%5s: %4.1f%%\n", party_name, (100 * party_vote / total_vote)
  # %5s a string (s) of fixed width 5 or more (5) aligned right (if it was -5 it would be left)
  # %4.1f a number (f) with one decimal (.1) and total width 4 (4) aligned right (4)
  # %% an actual %
}</p>

<h1>same program as before</h1>

<p>NR > 1 &amp;&amp; NF   {total += $6}
$NF == "Con"   {total_con += $6}
$NF == "Lab"   {total_lab += $6}
$NF == "UKIP"  {total_ukip += $6}
$NF == "LD"    {total_ld += $6}
$NF == "Green" {total_green += $6}
$NF == "SNP"   {total_snp += $6}
END {
  print "TOTAL: " total
  print_party_percentage("Con", total_con, total)
  print_party_percentage("Lab", total_lab, total)
  print_party_percentage("UKIP", total_ukip, total)
  print_party_percentage("LD", total_ld, total)
  print_party_percentage("SNP", total_snp, total)
}</p>

<h1>output</h1>

<p>TOTAL: 30697255
  Con: 36.8%
  Lab: 30.4%
 UKIP: 12.6%
   LD:  7.9%
  SNP:  4.7%
```</p>

<h3>Using arrays to group data</h3>

<p>There is still some copy and past code because we are hardcoding the parties. We can use arrays to group whatever parties we find.</p>

<p>``` bash</p>

<h1>same formatting function as before</h1>

<p>function print_party_percentage(party_name, party_vote, total_vote) {
  printf "%5s: %4.1f%%\n", party_name, (100 * party_vote / total_vote)
}</p>

<h1>skip empty and header lines</h1>

<p>NR > 1 &amp;&amp; NF  {
  # runnint total
  total += $6
  # create or update running total for current party
  party_totals[$NF] += $6
}</p>

<h1>when all records are processed</h1>

<p>END {
  print "TOTAL: " total
  # print a line for each party
  for (party in party_totals)</p>

<pre><code>print_party_percentage(party, party_totals[party], total)
</code></pre>

<p>}</p>

<h1>output - there are a LOT of tiny local parties</h1>

<p>TOTAL: 30697255
  UUP:  0.4%
Left Unity - Trade Unionists and Socialists:  0.0%
  IZB:  0.0%
Respect:  0.0%
  SSP:  0.0%
  NSW:  0.0%
The 30-50 Coalition:  0.0%
.... and so on
```</p>

<p>Oh - turns out if you include all the novelty parties there are 132 of them across the UK. We need to sort the array and only print the top X items. Turns out it is quite complicated.</p>

<h3>Sorting array</h3>

<p>Standard awk's array are not sortable. This was a design choice - only associative arrays are supported, so there is no order, hence they can't be sorted in any meaningful way. <a href="https://www.gnu.org/software/gawk/manual/gawk.html#Arrays">gawk, however, has two array sorting functions</a> - how do they do it? They actually create a new associative array, with all the values from the original but none of they keys; they keys are replaced by new ones, in order. Then you use a for loop (not the standard for in) to read all the array "in order". This is all well and good if you don't need the keys, but I do (they are the name of the party). Besides, I am using awk and not gawk.</p>

<p>The best approach is to create a new array with just the keys, sort that array, and then loop through it in order in order to find out which keys of the original array to read.
``` bash</p>

<h1>kickstarts the sort process</h1>

<h1>puts all the sorted keys into a separate array. if i</h1>

<p>function homebrew_asort(original, processed) {
  # before we use the array we must be sure it is empty
  empty_array(processed)
  original_length = copy_and_count_array(original, processed)
  qsort(original, processed, 0, original_length)
  return original_length
}</p>

<h1>removes al values</h1>

<p>function empty_array(A) {
  for (i in A)</p>

<pre><code>delete A[i]
</code></pre>

<p>}</p>

<h1>awk doesn't even have an array size function... you also have to roll out your own</h1>

<p>function copy_and_count_array(original, processed) {
  for (key in original) {</p>

<pre><code># awk doesn't seem to like array[0] -  so we start from 1
size++
processed[size] = key
</code></pre>

<p>  }
  return size
}</p>

<h1>Adapted from a script from awk.info</h1>

<h1>http://awk.info/?quicksort</h1>

<p>function qsort(original, keys, left, right,   i, last) {
  if (left >= right)  return
  swap(keys, left, left + int( (right - left + 1) * rand() ) )
  last = left
  for (i = left+1; i &lt;= right; i++)</p>

<pre><code>if (original[keys[i]] &lt; original[keys[left]])
  swap(keys, ++last, i)
</code></pre>

<p>  swap(keys, left, last)
  qsort(original, keys, left, last-1)
  qsort(original, keys, last+1, right)
}
function swap(A, i, j,   t) {
  t = A[i]; A[i] = A[j]; A[j] = t
}</p>

<h1>same formatting function as before</h1>

<p>function print_party_percentage(party_name, party_vote, total_vote) {
  printf "%5s: %4.1f%%\n", party_name, (100 * party_vote / total_vote)
}</p>

<h1>same main action as before</h1>

<p>NR > 1 &amp;&amp; NF  {
  total += $6
  party_totals[$NF] += $6
}</p>

<h1>when all records are processed</h1>

<p>END {
  parties_count = homebrew_asort(party_totals, keys)
  for  (i = parties_count; i >= parties_count - 5; i--)</p>

<pre><code>print_party_percentage(keys[i], party_totals[keys[i]], total)
</code></pre>

<p>}
```</p>

<p>And the output
<code>bash
  Con: 36.8%
  Lab: 30.4%
 UKIP: 12.6%
   LD:  7.9%
  SNP:  4.7%
Green:  3.8%
</code></p>

<h2>Print first or last x characters of a line</h2>

<p>You can easily mimick <code>head -c</code> or <code>tail -c</code> with awk - if you really want to.
``` bash</p>

<h1>equivalent</h1>

<p>$ awk '{print substr($0, 1, 32)}' xxx
$ head -c 32 xxx</p>

<h1>equivalent</h1>

<p>$ awk 'END {print substr($0, length($0) - 30, 32)}' xxx
$ tail -c 32 xxx
```</p>

<p>But with awk you can also skip a few characters into a file
``` bash</p>

<h1>no heard or tail equivalent - print characters 32 to 64</h1>

<p>$ awk '{print substr($0, 32, 32)}' xxx
```</p>

<h2>Other examples</h2>

<p>The <a href="http://awk.info/">awk.info</a> website has some <a href="http://awk.info/?OneLiners">one liners</a> with extensive <a href="http://www.catonmat.net/blog/awk-one-liners-explained-part-one/">explanations</a></p>

<p>The <a href="http://www.math.utah.edu/docs/info/gawk_4.html">gawk manual includes some one liners</a> which are compatible with standard awk.</p>

<p>The Unix School: <a href="http://www.theunixschool.com/2012/06/awk-10-examples-to-group-data-in-csv-or.html">10 examples to group data in a CSV or text file</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Back to the classics: awk]]></title>
    <link href="http://gotofritz.net/blog/geekery/back-to-the-classics-awk/"/>
    <updated>2015-07-15T23:19:00+02:00</updated>
    <id>http://gotofritz.net/blog/geekery/back-to-the-classics-awk</id>
    <content type="html"><![CDATA[<p>In this age of npm and github and easily available modules in any language of your choice, it is easy to forget the old Unix workhorses. Here's a look at awk, a shell utility that allows you to treat and manipulate text files as if they were databases. In <a href="/blog/geekery/a-selection-of-akw-scripts/">Part 2</a> there are a few sample scripts.</p>

<!--more-->


<h2>What is awk?</h2>

<p><code>Awk</code> is both the name of the command line utility, and the language used for it. It was invented at Bells Labs at the peak of punk rock, 1977, and its name is simply the initials of its three creators. Awk reads input (a file, or a stream) one line (one "record") at the time, splits it into fields by blank space (these are all defaults that can be changed), and then uses the instructions in the awk language to manipulate these fields and generate some output. The ability to read files as streams is a big plus - it means the memory footprint is the same if you read a file of 1Kb or 200Tb; for a larger file it will just take longer.</p>

<p>Awk is standard with the version of bash that comes with OS X, and several others. There is another variant which is widespread - gawk, GNU awk. It is actually better than the original, because it offers array sort and length functions, the ability to include files, and more flexible rules for splitting input in fields. Here I will limit myself to the standard awk.</p>

<h3>Example awk in action</h3>

<p>Here's what the simplest awk program looks like - this is basically <code>cat</code>
``` bash</p>

<h1>awk loads the short program: {print} and wait for user to type stuff</h1>

<p>$ awk '{print}'</p>

<h1>as you type, the shell prints out what you are typing. Awk is waiting</h1>

<h1>for a <RETURN> outside a ''</h1>

<p>It was a bright cold day in April, and the clocks were striking thirteen.</p>

<h1>now awk kicks in and runs the program on the input</h1>

<h1>{print} simply prints the input line as it is, so here it is again</h1>

<p>It was a bright cold day in April, and the clocks were striking thirteen.
$
```</p>

<p>The strong point of <code>awk</code> is that it automatically splits lines of text as if they were "columns" in a spreadsheet and assigns each column to a variable (a "field"). Then you can manipulate them and spit them out
``` bash</p>

<h1>awk loads a slightly more complex program and waits</h1>

<p>$ awk '{print $3 ": " $1 + $2}'</p>

<h1>waiting for a <RETURN> outside a ''</h1>

<p>10 20 Toronto</p>

<h1>this line is split into 3 "columns", and</h1>

<h1>10 is assigned to $1, 20 to $2, and Toronto to $3</h1>

<h1>then the program {print "$3: " $1 + $2} is run - it adds $1 + $2 and</h1>

<h1>prints the result out, with some extra text (the :)</h1>

<p>Toronto: 30</p>

<h1>now it waits for the next line</h1>

<p>20 30 Miami</p>

<h1>same program run on it</h1>

<p>Miami: 50
$
```</p>

<p>Despite its simplicity, you can take awk quite far - for example creating <a href="http://awk.info/?doc/story.html">a random sci-fi plot generator</a>.</p>

<h2>Running awk programs and redirecting input, output</h2>

<p>Running awk on STDIN is not very useful, but of course you can use Unix magic to redirect the input and / or output of the program
``` bash</p>

<h1>awk will treat the second argument as a path to a file to read from</h1>

<p>$ awk '{print}' some_data.txt
... # prints whatever was in some_data.txt
$</p>

<h1>exactly the same thing but done differently - redirecting file to STDIN</h1>

<p>$ awk '{print}' &lt; some_data.txt
... # prints whatever was in some_data.txt
$</p>

<h1>you can read several files, in order</h1>

<p>$ awk '{print}' some_data.txt more_data.txt
...
$</p>

<h1>now the processed data goes to a separate file</h1>

<p>$ awk '{print}' some_data.txt > result.txt
$</p>

<h1>the awk program itself can be loaded to a file - here this file is created</h1>

<p>$ echo '{print}' > awk.txt</p>

<h1>passing the command on to awk with the -f option</h1>

<p>$ awk -f awk.txt some_data.txt > result.txt
$</p>

<h1>mixing STDIN with files. The "-" is substituted by STDIN,  which is dealt with</h1>

<h1>after some_data.txt</h1>

<p>$ ls -l | awk '{print}' some_data.txt - more_data.txt
$ ... # prints all lines from some_data.txt
$ ... # prints result of ls -l (this is the "-")
$ ... # prints all lines from more_data.txt
$</p>

<h1>pass some text into awk, then run an awk program on it</h1>

<p>$ echo '1 2 3' | awk '{print}'
$ 1 2 3
$</p>

<h1>using the curl util to download a csv file, piping it to awk, and running</h1>

<h1>the simple awk program on it</h1>

<p>$ curl http://is.gd/eUrbOZ | awk '{print}'
Forename,Surname,Description on ballot paper,Constituency Name,PANo,Votes,Share
... # etc
```</p>

<h2>Anatomy of an awk program</h2>

<p>So far the awk example consisted of simple one liners - but awk programs can consist of several instructions ("actions"). You can still write them out on the shell:
``` bash</p>

<h1>note: the ">" is added automatically when hitting return inside a '',</h1>

<h1>and the space between > and { was added manually to make it line up</h1>

<p>$ awk '{print}</p>

<blockquote><pre><code> {print}
 {print}'
</code></pre>

<h1>now that the closing ' was typed, awk kicks in. this programs simply</h1>

<h1>prints out whatever you type three times</h1>

<p>oh # typed by you
oh # printed by awk 3 times
oh
oh
```</p></blockquote>

<p>In this tutorial I will put the awk program in its own file and load it from the command line - just to make formatting easier and allow comments. The file loaded here has suffix ".awk" but that's irrelevant, it could be any filename.
<code>bash
$ awk -f example.awk some_input_text.txt
</code></p>

<p>An awk program consists of a list of actions, one after the other, and typically one per line (they can be broken up though). There are two special types of actions - BEGIN actions are executed only once, before the text is scanned, and END only once, afterwards. All other actions are executed in order on every line of text. Assume your input file includes increasing integers, one per line
<code>bash
1
2
3
</code></p>

<p>Then the program below
<code>bash
BEGIN { print "START!" }
{print "--------------"}
{print}
{print}
{print}
END { print "END!" }
</code></p>

<p>Would produce
``` bash</p>

<h2>START!</h2>

<p>1
1</p>

<h2>1</h2>

<p>2
2</p>

<h2>2</h2>

<p>3
3
3
END!
```</p>

<p>Note that actions can be in any order (they will be executed in the order they are written) and there can be multiple BEGIN and END, so the following is also a legal program.
<code>bash
{print "--------------"}
{print}
END { print "END!" }
BEGIN { print "START!" }
{print}
END { print "Copyright 2005" }
{print}
</code>
The way the program is dealt with is:</p>

<ul>
<li>all the BEGIN actions are executed, in order</li>
<li>input is read one line at the time, and for each line

<ul>
<li>the line is split into fields</li>
<li>each action, in turn, is run on the fields</li>
</ul>
</li>
<li>all the END actions are run at the end</li>
</ul>


<p>Inside the actions awk offers what most programming languages offer - variable, loops, tests, etc.</p>

<h3>Actions formatting</h3>

<p>Awk follows Unix conventions on most things, so in case of doubt whatever works in Bash scripts tends to work.</p>

<p>``` bash</p>

<h1>a 'normal' one lne</h1>

<p>BEGIN { print "START" }</p>

<h1>you can add newlines for formatting - this is equivalent to the above</h1>

<p>BEGIN {
  print "START"
}
-> START
-> START</p>

<h1>as in Bash scripts, you can use the semicolon to separate multiple statements</h1>

<h1>on the same line...</h1>

<p>BEGIN { print "STA"; print "RT";}</p>

<h1>or you can write them one per line, with or without semicolon</h1>

<p>BEGIN { print "STA"</p>

<pre><code>    print "RT" }
</code></pre>

<p>-> STA
   RT
-> STA
   RT
```</p>

<h2>Variables</h2>

<p>Awk makes several variables available to the programs - some are loaded when the program is launched, some are updated with each line read, some are created by the program itself.</p>

<h3>Field Variables</h3>

<p>Whenever awk reads a line, it splits it into "fields" by white-space / tab (this is the default and can be overridden), Then each field is copied to a variable $1, $2, .... in order - there is no limit. Additionally, $0 contains the whole line.
``` bash</p>

<h1>assume this file</h1>

<p>1 2 3 4 5 6 7</p>

<h1>the following two lines are equivalent</h1>

<p>{ print }
{ print $0 }
-> 1 2 3 4 5 6 7
-> 1 2 3 4 5 6 7</p>

<h1>only prints some fields we are interested in</h1>

<p>{ print $1 " " $3 }
-> 1 3
```</p>

<p>The field number doesn't have to be a constant - it can be an expression or a variable. For example, the global variable NF contains the number of the last field and is updated which every line read. So if there are 7 fields, NF would be 7, and $NF would be $7, i.e. the last field
``` bash</p>

<h1>assume this file</h1>

<p>1 2 3 4 5 6 7</p>

<h1>both mean first and last field - but the first version only works if there are</h1>

<h1>7 fields, the second always works</h1>

<p>{print $1 " " $7}
{print $1 " " $NF}
-> 1 7
-> 1 7
#</p>

<h1>print the last two fields</h1>

<p>{print $(NF-1) " " $NF}
-> 6 7
```</p>

<p>Another useful global variable that gets updated for each record is NR - this is the record number
``` bash</p>

<h1>feed a four line input into awk</h1>

<p>$ echo 'a</p>

<blockquote><p>b
c
d' | awk '{print NR ") " $1}'</p>

<h1>it prints the line number, ), and the first (and only) field</h1>

<p>1) a
2) b
3) c
4) d
```</p></blockquote>

<p>You can assign to a field variable with the '=' operator, thereby changing the record content:
``` bash</p>

<h1>adding something to a field - will only works if it's a number</h1>

<p>{$3 = ($3 + 100)</p>

<h1>now print the updated line</h1>

<p>print $0}
-> 1 2 103 4 5 6 7
```</p>

<p>If you assign to a field variable that doesn't exist, it will be added to the record
``` bash</p>

<h1>the record only contains $1 and $2;</h1>

<p>$ echo 1 2 | awk '{print $0}'
$ 1 2
$</p>

<h1>the program adds two new fields</h1>

<p>$ echo 1 2 | awk '{$3 = 3; $4 = 4; print $0}'
$ 1 2 3 4
```</p>

<h3>Global variables</h3>

<p>A few variables are set when the program is launched. Here's a very short list - if you need to play with these you probably want to get yourself a book on awk.</p>

<table>
<thead>
<tr>
<th></th>
<th align="right">Variable</th>
<th align="left"> </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="right"> ARGV    </td>
<td align="left"> array of command line arguments</td>
</tr>
<tr>
<td></td>
<td align="right"> ARGC    </td>
<td align="left"> number of command line arguments</td>
</tr>
<tr>
<td></td>
<td align="right"> ENVIRON </td>
<td align="left"> associative array with environment. Depends on system</td>
</tr>
<tr>
<td></td>
<td align="right"> FILENAME</td>
<td align="left"> self explanatory</td>
</tr>
</tbody>
</table>


<h3>User defined variables</h3>

<p>To create your own variable, just start assigning to them with the '=' operator - awk will initialize them to an emptry string (which becomes a 0 if used in numeric context). The type of variable is dynamic and can vary during its lifetime.</p>

<p>In the example below, awk is used on the ls command to find the total size of a folder.</p>

<p>``` bash</p>

<h1>ls -la returns listings in the form:</h1>

<h1>-rw-rw-r--    1 gotofritz staff   1513 Dec 15  2013 .bash_profile</h1>

<h1>awk simply collects each filesize and adds it to a running total,</h1>

<h1>then prints it at the end</h1>

<p>$ ls -la | awk '    { total += $5 }</p>

<pre><code>            END { print total }'
</code></pre>

<p>-> 158448
```</p>

<h3>Arrays</h3>

<p>Awk has associative arrays, similar to PHP's or Javascript. You create an array by using it, no need to initialize it.
``` bash</p>

<h1>assume this file</h1>

<p>10 Life changes fast
20 Life changes in the instant
30 You sit down to dinner and life as you know it ends
40 The question of self-pity</p>

<h1>creates my_array and inserts all lines into it</h1>

<p>{ my_array[$1] = $2 }</p>

<h1>creates - note that array is sparse</h1>

<p>my_array[10] = "Life changes fast"
my_array[20] = "Life changes in the instant"
my_array[30] = "You sit down to dinner and life as you know it ends"
my_array[40] = "The question of self-pity"</p>

<h1>string keys are also possible</h1>

<p>{ my_array["name"] = "Homer" }
```</p>

<p>One thing that is different in awk is that multidimensional arrays use a single set of square brackets to wrap both indices
``` bash</p>

<h1>assume this file</h1>

<p>dad homer
mum marge
son bart</p>

<h1>creates a two dimensional array</h1>

<p>{ family["simpsons",$1] = $2 }
-> creates
family["simpsons","dad"] = "homer"
family["simpsons","mum"] = "marge"
family["simpsons","son"] = "bart"
```</p>

<p>Note that arrays in awk are pretty awkward. There are no built in functions to deal with them except for the for ... in loop. If you need to sort, or even just find out the length, you'll have to write your own functions. There are a couple in <a href="/blog/geekery/a-selection-of-akw-scripts/">Part 2</a>. Alternatively, use gawk which has <a href="https://www.gnu.org/software/gawk/manual/gawk.html#Arrays">better array handling</a>.</p>

<h3>Regular expressions</h3>

<p>A regular expression (regexp) is a mini programming language which is used to describe variable strings; it is embedded in most programming languages.
Regexps are enclosed in slashes and use a combination of literal characters and punctuation to describe strings. The operator ~ is used to match a regexp, and !~ to ensure it is not matched.</p>

<p>Regular expressions is a complicated topic of its own; here is just a quick introduction</p>

<p>``` bash</p>

<h1>print all lines with "gmail" in the 1st field</h1>

<p>{ if ($1 ~ /gmail/) print}</p>

<h1>prints all lines EXCEPT those with "gmail"</h1>

<p>{ if ($1 !~ /gmail/) print}</p>

<h1>^ indicates start of string.</h1>

<h1>this matches "tom" "tomato" but not "atom"</h1>

<p>{ if ($1 ~ /<sup>tom/)</sup> print}</p>

<h1>$ indicates end of string</h1>

<h1>this matches "tom", "atom" but not "tomato"</h1>

<p>{ if ($1 ~ /tom$/) print}</p>

<h1>this matches "tom", not "atom" and not "tomato"</h1>

<p>{ if ($1 ~ /<sup>tom$/)</sup> print}</p>

<h1>. matches any character.</h1>

<h1>this matches "bear" "boar" but not "bar"</h1>

<p>{ if ($1 ~ /b..r/) print}</p>

<h1>[ABC] matches one character from the set "A", "B", "C"</h1>

<h1>this matches "boar" "bear" but not "blar"</h1>

<p>{ if ($1 ~ /b[oe]ar/) print}</p>

<h1>[<sup>ABC]</sup> matches one character which is anything except "A", "B", "C"</h1>

<h1>this matches "blar" but neither "boar" nor "bear"</h1>

<p>{ if ($1 ~ /b[<sup>oe]ar/)</sup> print}</p>

<h1>(abc) groups the expression abc as a unit.</h1>

<h1>| is an "or"</h1>

<h1>\ is used to scape special characters, i.e. treat them as normal characters</h1>

<h1>in this case we want to treat the '.' as a period and not "any character"</h1>

<h1>the following matches @gmail.com or @yahoo.com</h1>

<p>{ if ($1 ~ /@(gmail)|(yahoo).com/) print}</p>

<h1>* means repeat zero or more. + is repeat once or more. ? is repeat 0 or 1</h1>

<p>{ if ($1 ~ /&lt;[<sup>>]+>[<sup>&lt;]*&lt;/[<sup>>]+>.?/)</sup></sup></sup> print }</p>

<h1>the following matches &lt; followed by one or more (+) of anything except >, then ></h1>

<h1>then zero or more (*) of anything except &lt;</h1>

<h1>then </ followed by one or more (+) of anything except >, then ></h1>

<h1>then an optional .</h1>

<p>```</p>

<h2>Statements, operators, and function</h2>

<h3>Control statements</h3>

<p>Awk has the usual loops and conditionals familiar from C. Braces are optional for single nested statements
``` bash</p>

<h1>braces are optional for single statements</h1>

<p>for (name in list_of_names)
  print name</p>

<p>for (capital_city in country) {
  print capital_city
}</p>

<h1>but needed for multiple statements</h1>

<p>if (NR % 2 == 0) {
  $2 = $1 * 2
  print $0
}
```</p>

<h4>if-else</h4>

<p>Awk doesn't have booleans. Instead it treats the number 0 or the empty string "" as false, and any other value (including the string "0") as true. The comparison operators are the familiar ones, with double equal sign for equality, plus the tilde ~ and !~ for regular expression matching, and "in" for array existence
<code>bash
{ if ($1 == "full") ... }
{ if ($2 &lt; 0.5) ... }
{ if ($0 ~ /Republican/) print $0 } ... # matches regexp
{ if ($1 !~ /Completed/) print $0 } ... # rejects regexp
{ if (capital_city in country) print country["capital_city"] }
</code></p>

<h4>loops</h4>

<p>Awk has both for and while loops (including do-while). Additionally, there is the for-in loop for sparse arrays
``` bash</p>

<h1>assume file</h1>

<p>1 10 100
2 20 200</p>

<h1>both these programs will print each line with fields back-to-front</h1>

<h1>while loop version...</h1>

<p>{ i = NF
  line = ""
  while (i) {</p>

<pre><code>line =  line " " $i
i--
</code></pre>

<p>  }
  print line
}</p>

<h1>for loop version</h1>

<p>{ line = ""
  for (i=NF; i>0; i--) {</p>

<pre><code>line =  line " " $i
</code></pre>

<p>  }
  print line
}
-> 100 10 1
   200 20 2</p>

<h1>puts each line of input into the array</h1>

<p>{ lines[$NR] = $0 }</p>

<h1>at end prints all the lines</h1>

<p>END {
  for (line in lines)</p>

<pre><code>print line
</code></pre>

<p>}
<code>``
</code>break<code>and</code>continue` statements are available to exit a loop prematurely or skipping an iteration respectively.</p>

<h4>next</h4>

<p><code>next</code> is used to stop precessing a record and moving on to the next
<code>bash
{ if ($5 == "") next }
{ print $5 $4 }
</code></p>

<h3>Awk numeric operators</h3>

<p>The usual maths operators can be used: +, -, /, * , ++, -- plus % for modulus, ^ for exponentiation. Unary + converts to a number
``` bash
echo "1</p>

<blockquote><p>2
3
4" | awk '{print $1 ^ 2}'
1
4
9
16
```</p></blockquote>

<h3>String concatenation</h3>

<p>Concatenating string in awk is slightly weird. There is no string concatenation operator; just put the strings next to each other. Because of that it is recommended to use parenthesis except for trivial cases. Alternatively, <code>print</code> can take multiple comma separated arguments - and they will be printed with a space separating them
``` bash</p>

<h1>assume this file</h1>

<p>1
2
3
4</p>

<h1>the strings ($1..) and "a" are concatenated (no space between them) and</h1>

<h1>the resulting string is passed to print</h1>

<p>{print ($1+2) "a"}
3a
4a
5a
6a</p>

<h1>two separate strings are passed to print -  a space is put between them</h1>

<p>{print ($1+2), "a"}
3 a
4 a
5 a
6 a</p>

<h1>string concatenation works for variables too</h1>

<p>{ something = $1 "--"
  print something }
1--
2--
3--
4--
```</p>

<h3>Built in functions</h3>

<p>There are a number of built in functions: numeric ones like cosine, square root, random; string functions like print or string length; time functions and bitwise functions. You can easily find out what they are by looking at the output of <code>man awk</code>.</p>

<p>Worth nothing that besides <code>print</code> awk also offers <code>printf</code>, i.e. "print formatted". Printf is common to many Unix tools and languages. You give a string with some placeholders and rules, and then you pass variables to "plug in" those placeholders. The important thing is the rules, which control things like right alignment, decimal precision, zero padding for numbers, etc. A statement looks like this:
``` bash
{ printf "%-10s %04.3f%% \n", $1, $2 }</p>

<h1>placeholders start with %</h1>

<h1>%-10s is a string (s), and is left aligned (-) within a field 10 spaces wide (10)</h1>

<h1>%07.3f is a decimal number or float (f), the toal length has to be at least 7</h1>

<h1>characters (7) and is padded with zeroes if too small (0) and has</h1>

<h1>3 decimals (3) and minimum 3 in the integer part (7 - 3 decimals - the point)</h1>

<h1>%% if you want to print an actual %, you need to type it twice %%</h1>

<h1>\n you need to supply the new line manually</h1>

<p>```
<a href="http://www.math.utah.edu/docs/info/gawk_7.html#SEC61">More information on printf</a>.</p>

<h3>User defined functions</h3>

<p>You can define functions anywhere in your code, outside actions. They are pretty similar to Javascript
``` bash</p>

<h1>define funtion outside rules - could be at the bottom of file</h1>

<p>function my_func(field_content) {
  print "FIELD: " field_content
}</p>

<h1>now use in rules</h1>

<p>{my_func($1)}
```</p>

<h2>Patterns</h2>

<p>Previously I described an awk program as a series of actions, with the special case of BEGIN and END. That's not entirely correct. An awk program consists of a sequence of actions and optional <em>patterns</em>; BEGIN and END are two special patterns. Incidentally, there is also a BEGINFILE and ENDFILE, for when processing more than one file at the time.</p>

<p>BEGIN and END are special because they identify actions which are not executed for every line of input, but before or after the whole program is run. The other patterns are used on every line to determine whether the action should be run for that particular line or not. Patterns are espressions that return false (i.e., 0 or "") or true (anything else). When the pattern returns true, the rules is executed.</p>

<h3>Regular expression patterns</h3>

<p>Regular expressions can be used as pattern; they match the entire line. An exclamation mark reverses the match. Boolean operators can be used to combine patterns</p>

<p>``` bash</p>

<h1>print lines with an email address</h1>

<h1>(very lazy match - will only work if all email addresses are well formed)</h1>

<p>/@/ { print $3}</p>

<h1>prints all lines except those with a gmail address</h1>

<p>! /@gmail./ { print $0 }</p>

<h1>prints lines with an @ and the sequence 0160</h1>

<p>/@/ &amp;&amp; /0160/ { print }
```</p>

<p>The regular expressions above are a shortcut for <code>$0 ~ /pattern/</code>, i.e. "apply the regexp to whole line". Similar rules can be made for individual fields...
``` bash</p>

<h1>matches only the regx on one field</h1>

<p>$1 ~ /Anthony/ { print }
```</p>

<p>..and all expressions seen so far
``` bash</p>

<h1>print even lines</h1>

<p>NR % 2 == 0 { print }</p>

<h1>print only if length of 1st field is greater than 3</h1>

<h1>length is a string function mentioned above</h1>

<p>length($1) > 3 { print }
```</p>

<p>The reason we have been able to run program without patterns is because there is a special pattern, the empty pattern, which matches every line. In fact we could have a program which is just a pattern; the default action <code>{print}</code> would be executed.
``` bash</p>

<h1>prints whole line, default action</h1>

<p>$1 == "complete"
```</p>

<h2>Splitting records and fields differently from default</h2>

<p>By default awk treats each line as a record. In reality what it does is to split the input by a record separator, stored in the variable RS, which happens to be the new line character. You can change that in an awk program.
``` bash</p>

<h1>separate records by semicolon</h1>

<p>$ echo "1 2 3;4 5 6;7 8 9" | awk 'BEGIN {RS = ";" }</p>

<blockquote><pre><code>                            {print}'
</code></pre>

<p>1 2 3
4 5 6
7 8 9
```</p></blockquote>

<p>Something similar is possible with the field separator, which is stored in the variable FS. By default it is equal to the regexp <code>[ \t\n]+</code>, i.e. any number of consectuve spaces of any type. Note that in reality awk cheats - leaving FS default doesn't just mean setting it to <code>[ \t\n]+</code>, but also trimming $0 of leading and trailing empty space before processing it.
``` bash</p>

<h1>separate fields by comma</h1>

<p>$ echo "1,2,3
4,5,6
7,8,9" | awk 'BEGIN {FS = "," }</p>

<blockquote><pre><code>        {print}'
</code></pre>

<p>1,2,3
4,5,6
7,8,9
```</p></blockquote>

<p>You can combine the two together if, for example, your data has one field per line and records are separated by multiple lines - an empty RS means "any number of consecutive \n ""
``` bash</p>

<h1>assume this data</h1>

<p>homer simpson
dad</p>

<p>marge simpson
mum</p>

<h1>separate records by any number of newlines, and have one field per line</h1>

<p>BEGIN {RS=""; FS="\n"}
{ print $1 " (" $2 ")" }</p>

<p>-> homer simpson (dad)
   marge simpson (mum)
```</p>

<h2>Passing option to awk</h2>

<p>A field separator (but not a record separator) can be also passed to an awk program in two ways. First of all, awk has a special option for it, -F (note that there is no space between it and the separator). And awk allow passing of variables with the -v syntax, so you could just pass FS that way.
``` bash</p>

<h1>change separator from within program</h1>

<p>BEGIN {FS = "," }</p>

<h1>pass separator with special option -F - note that you don't need quotes</h1>

<p>$ echo "1,2,3</p>

<blockquote><p>4,5,6" | awk -F, '{print}'
1,2,3
4,5,6</p></blockquote>

<h1>pass separator as external var with -v</h1>

<p>$ echo "1,2,3</p>

<blockquote><p>4,5,6" | awk -v FS="," '{print}'
1,2,3
4,5,6i</p></blockquote>

<h1>in fact you can pass any variable of your choice with -v</h1>

<p>$ echo "" | awk -v WHAT="grow up" '{print "All children, except one, " WHAT}'
All children, except one, grow up
```</p>

<h2>Reading CSV files in awk</h2>

<p>The naive approach would be to simply set FS="," - but that doesn't cover the fact that some fields are surrounded by quotation marks and others aren't, and sometimes you have newlines and / or commas inside a field. <a href="http://www.linuxquestions.org/questions/programming-9/awk-with-csv-files-881103/">Here are some examples scripts</a> people have put together to solve the issues. They are also good examples of fairly complex awk scripts.</p>

<p>Personally I think that's taking things too far - if you have to force awk to create arrays to store  manipulated record fragments you may as well use a fully fledged scripting language.</p>

<p>Another approach is to use gawk, and <a href="https://www.gnu.org/software/gawk/manual/gawk.html#Splitting-By-Content">its FPAT variable</a></p>

<h2>Learning more about awk</h2>

<p>With that all the main awk topics were touched on. If you want to go deeper I recomend <a href="http://www.staff.science.uu.nl/~oostr102/docs/nawk/nawk_toc.html">The AWK Manual</a>, or <a href="http://shop.oreilly.com/product/9780596000707.do">one of the O'Reilly books</a></p>
]]></content>
  </entry>
  
</feed>
