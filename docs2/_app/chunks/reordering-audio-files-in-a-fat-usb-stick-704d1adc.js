import{S as Js,i as Ks,s as Qs,e as o,t as l,k as f,c as a,a as i,d as t,h as n,m as p,b as u,g as d,I as s,E as is}from"./index-e78f36eb.js";function $s(Ms){let m,b,ee,ge,Te,X,et,Ae,Z,tt,De,c,st,te,ot,at,se,it,rt,oe,lt,nt,ae,ut,dt,ie,ft,pt,re,ct,ht,xe,z,mt,Pe,y,_,le,vt,Be,J,Et,Oe,I,S,ne,kt,Ce,K,wt,Fe,N,Us=`<code class="language-bash"><span class="token operator">></span> brew <span class="token function">install</span> fatsort
<span class="token operator">==</span><span class="token operator">></span> Downloading https://ghcr.io/v2/homebrew/core/help2man/manifests/1.49.1
<span class="token punctuation">..</span>.</code>`,Re,T,A,ue,bt,He,v,yt,de,_t,It,fe,St,Tt,Le,M,Vs=`<code class="language-bash"><span class="token operator">></span> fatsort /Volumes/DIE_DREI
device_open: Is a directory<span class="token operator">!</span>
openFileSystem: Is a directory<span class="token operator">!</span>
sortFileSystem: Failed to <span class="token function">open</span> <span class="token function">file</span> system<span class="token operator">!</span>
main: Failed to <span class="token function">sort</span> <span class="token function">file</span> system<span class="token operator">!</span></code>`,Ne,E,At,pe,Dt,xt,ce,Pt,Bt,Me,U,js=`<code class="language-bash"><span class="token operator">></span> <span class="token function">mount</span>
 /dev/disk1s5s1 on / <span class="token punctuation">(</span>apfs, sealed, local, read-only, journaled<span class="token punctuation">)</span>
devfs on /dev <span class="token punctuation">(</span>devfs, local, nobrowse<span class="token punctuation">)</span>
/dev/disk1s2 on /System/Volumes/Preboot <span class="token punctuation">(</span>apfs, local, journaled, nobrowse<span class="token punctuation">)</span>
<span class="token punctuation">..</span>.
/dev/disk5s1 on /Volumes/DIE_DREI <span class="token punctuation">(</span>msdos, local, nodev, nosuid, noowners<span class="token punctuation">)</span></code>`,Ue,D,Ot,he,Ct,Ft,Ve,x,P,me,Rt,je,k,ve,Ht,Lt,Ee,Nt,Mt,Ye,V,Ys=`<code class="language-bash"><span class="token operator">></span>  <span class="token function">sudo</span> diskutil unmount /Volumes/DIE_DREI
Password:
 Volume DIE_DREI on disk5s1 unmounted</code>`,We,B,O,ke,Ut,qe,Q,Vt,Ge,j,Ws=`<code class="language-bash"><span class="token operator">></span> <span class="token function">sudo</span> fatsort /dev/disk5s
File system: FAT32.

Sorting directory /
<span class="token punctuation">..</span>.
Directory reordered. Writing changes.</code>`,Xe,C,F,we,jt,Ze,w,Yt,be,Wt,qt,Y,Gt,ze,R,H,ye,Xt,Je,L,_e,W,Zt,zt,q,Jt,G,Kt,Qt;return{c(){m=o("h2"),b=o("a"),ee=o("span"),ge=l("FAT formatting"),Te=f(),X=o("p"),et=l("I use Macs, and have no use for the FAT system. But it is the most widely supported by consumer devices like my SONY CD/MP3 player, for example. So i have no choice."),Ae=f(),Z=o("p"),tt=l("Those devices play back songs in date creation order. That would be the creation time on the stick; i.e., the time one started transferring them to the stick. Your typical laptop copies a few of these files in parallel. So one never knows what those creation times might be. This is why they get jumbled up."),De=f(),c=o("p"),st=l("One solution could be to write a little script to change those times after copying those files. It could traverse the directory structure of the stick, and use the bash command "),te=o("code"),ot=l("touch"),at=l(". Or its python version. But it turns out neither works well on FAT. The python version of touch, "),se=o("code"),it=l("os.utime"),rt=l(", doesn\u2019t handle creation time. There are extensions which seem would work well, like "),oe=o("code"),lt=l("pywintypes"),nt=l(", "),ae=o("code"),ut=l("win32file"),dt=l(", "),ie=o("code"),ft=l("wintypes"),pt=l(" or "),re=o("code"),ct=l("win32-setctime"),ht=l(". But they rely on C executables that only run on Windows."),xe=f(),z=o("p"),mt=l("A better solution would be to write a script that copies the files one at the time. With a little pause to make sure the creation times are in order. That should work. But it would make copying files last much longer."),Pe=f(),y=o("h2"),_=o("a"),le=o("span"),vt=l("Enter fatsort"),Be=f(),J=o("p"),Et=l("Luckily there is a C utility that does the job quite well. And there is a precompiled version for homebrew, the standard installer for OS X."),Oe=f(),I=o("h3"),S=o("a"),ne=o("span"),kt=l("Step 1: install it"),Ce=f(),K=o("p"),wt=l("Your typical homebrew installation"),Fe=f(),N=o("pre"),Re=f(),T=o("h3"),A=o("a"),ue=o("span"),bt=l("Step 2: find out where the drive is mounted"),He=f(),v=o("p"),yt=l("The first instinct is to run it on the drive as it appears in Finder, i.e. "),de=o("code"),_t=l("/Volumes/--SOMETHING--"),It=l(". So for my USB stick, called "),fe=o("code"),St=l("DIE_DREI"),Tt=l(", it would be like in the command below. But that turns out to be too easy"),Le=f(),M=o("pre"),Ne=f(),E=o("p"),At=l("Instead I needed to find out what directory the USB device is "),pe=o("em"),Dt=l("mounted to"),xt=l(". There is a handy command for that, "),ce=o("code"),Pt=l("mount"),Bt=l(". So step 2 goes"),Me=f(),U=o("pre"),Ue=f(),D=o("p"),Ot=l("It\u2019s "),he=o("code"),Ct=l("/dev/disk5s1"),Ft=l(" I need to run fatsort on, not /Volumes/DIE_DREI."),Ve=f(),x=o("h3"),P=o("a"),me=o("span"),Rt=l("Step 3: unmount the drive"),je=f(),k=o("p"),ve=o("code"),Ht=l("fatsort"),Lt=l(" doesn\u2019t work on the USB stick if it\u2019s mounted. I didn\u2019t even know a device\u2019s content would be available even after unmounted! TIL. To unmount and run the next steps I will need "),Ee=o("code"),Nt=l("sudo"),Mt=l(" to gain superuser permissions"),Ye=f(),V=o("pre"),We=f(),B=o("h3"),O=o("a"),ke=o("span"),Ut=l("Step 4: reorder the files"),qe=f(),Q=o("p"),Vt=l("Now I am ready to reorder the files"),Ge=f(),j=o("pre"),Xe=f(),C=o("h2"),F=o("a"),we=o("span"),jt=l("And that was it."),Ze=f(),w=o("p"),Yt=l("It only takes a few seconds. It\u2019s a great little tool. Thanks Boris! If you enter "),be=o("code"),Wt=l("fatsort -h"),qt=l(" you can "),Y=o("a"),Gt=l("see some of the options you can pass to it"),ze=f(),R=o("h2"),H=o("a"),ye=o("span"),Xt=l("Prior art"),Je=f(),L=o("ul"),_e=o("li"),W=o("a"),Zt=l("fatsort homepage"),zt=f(),q=o("li"),Jt=l("I found "),G=o("a"),Kt=l("useful information about fatsort"),Qt=l(" in a blog called \u2018Unfinished Bitness\u2019"),this.h()},l(e){m=a(e,"H2",{id:!0});var r=i(m);b=a(r,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var rs=i(b);ee=a(rs,"SPAN",{class:!0}),i(ee).forEach(t),rs.forEach(t),ge=n(r,"FAT formatting"),r.forEach(t),Te=p(e),X=a(e,"P",{});var ls=i(X);et=n(ls,"I use Macs, and have no use for the FAT system. But it is the most widely supported by consumer devices like my SONY CD/MP3 player, for example. So i have no choice."),ls.forEach(t),Ae=p(e),Z=a(e,"P",{});var ns=i(Z);tt=n(ns,"Those devices play back songs in date creation order. That would be the creation time on the stick; i.e., the time one started transferring them to the stick. Your typical laptop copies a few of these files in parallel. So one never knows what those creation times might be. This is why they get jumbled up."),ns.forEach(t),De=p(e),c=a(e,"P",{});var h=i(c);st=n(h,"One solution could be to write a little script to change those times after copying those files. It could traverse the directory structure of the stick, and use the bash command "),te=a(h,"CODE",{});var us=i(te);ot=n(us,"touch"),us.forEach(t),at=n(h,". Or its python version. But it turns out neither works well on FAT. The python version of touch, "),se=a(h,"CODE",{});var ds=i(se);it=n(ds,"os.utime"),ds.forEach(t),rt=n(h,", doesn\u2019t handle creation time. There are extensions which seem would work well, like "),oe=a(h,"CODE",{});var fs=i(oe);lt=n(fs,"pywintypes"),fs.forEach(t),nt=n(h,", "),ae=a(h,"CODE",{});var ps=i(ae);ut=n(ps,"win32file"),ps.forEach(t),dt=n(h,", "),ie=a(h,"CODE",{});var cs=i(ie);ft=n(cs,"wintypes"),cs.forEach(t),pt=n(h," or "),re=a(h,"CODE",{});var hs=i(re);ct=n(hs,"win32-setctime"),hs.forEach(t),ht=n(h,". But they rely on C executables that only run on Windows."),h.forEach(t),xe=p(e),z=a(e,"P",{});var ms=i(z);mt=n(ms,"A better solution would be to write a script that copies the files one at the time. With a little pause to make sure the creation times are in order. That should work. But it would make copying files last much longer."),ms.forEach(t),Pe=p(e),y=a(e,"H2",{id:!0});var $t=i(y);_=a($t,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var vs=i(_);le=a(vs,"SPAN",{class:!0}),i(le).forEach(t),vs.forEach(t),vt=n($t,"Enter fatsort"),$t.forEach(t),Be=p(e),J=a(e,"P",{});var Es=i(J);Et=n(Es,"Luckily there is a C utility that does the job quite well. And there is a precompiled version for homebrew, the standard installer for OS X."),Es.forEach(t),Oe=p(e),I=a(e,"H3",{id:!0});var gt=i(I);S=a(gt,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var ks=i(S);ne=a(ks,"SPAN",{class:!0}),i(ne).forEach(t),ks.forEach(t),kt=n(gt,"Step 1: install it"),gt.forEach(t),Ce=p(e),K=a(e,"P",{});var ws=i(K);wt=n(ws,"Your typical homebrew installation"),ws.forEach(t),Fe=p(e),N=a(e,"PRE",{class:!0});var qs=i(N);qs.forEach(t),Re=p(e),T=a(e,"H3",{id:!0});var es=i(T);A=a(es,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var bs=i(A);ue=a(bs,"SPAN",{class:!0}),i(ue).forEach(t),bs.forEach(t),bt=n(es,"Step 2: find out where the drive is mounted"),es.forEach(t),He=p(e),v=a(e,"P",{});var $=i(v);yt=n($,"The first instinct is to run it on the drive as it appears in Finder, i.e. "),de=a($,"CODE",{});var ys=i(de);_t=n(ys,"/Volumes/--SOMETHING--"),ys.forEach(t),It=n($,". So for my USB stick, called "),fe=a($,"CODE",{});var _s=i(fe);St=n(_s,"DIE_DREI"),_s.forEach(t),Tt=n($,", it would be like in the command below. But that turns out to be too easy"),$.forEach(t),Le=p(e),M=a(e,"PRE",{class:!0});var Gs=i(M);Gs.forEach(t),Ne=p(e),E=a(e,"P",{});var g=i(E);At=n(g,"Instead I needed to find out what directory the USB device is "),pe=a(g,"EM",{});var Is=i(pe);Dt=n(Is,"mounted to"),Is.forEach(t),xt=n(g,". There is a handy command for that, "),ce=a(g,"CODE",{});var Ss=i(ce);Pt=n(Ss,"mount"),Ss.forEach(t),Bt=n(g,". So step 2 goes"),g.forEach(t),Me=p(e),U=a(e,"PRE",{class:!0});var Xs=i(U);Xs.forEach(t),Ue=p(e),D=a(e,"P",{});var Ke=i(D);Ot=n(Ke,"It\u2019s "),he=a(Ke,"CODE",{});var Ts=i(he);Ct=n(Ts,"/dev/disk5s1"),Ts.forEach(t),Ft=n(Ke," I need to run fatsort on, not /Volumes/DIE_DREI."),Ke.forEach(t),Ve=p(e),x=a(e,"H3",{id:!0});var ts=i(x);P=a(ts,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var As=i(P);me=a(As,"SPAN",{class:!0}),i(me).forEach(t),As.forEach(t),Rt=n(ts,"Step 3: unmount the drive"),ts.forEach(t),je=p(e),k=a(e,"P",{});var Ie=i(k);ve=a(Ie,"CODE",{});var Ds=i(ve);Ht=n(Ds,"fatsort"),Ds.forEach(t),Lt=n(Ie," doesn\u2019t work on the USB stick if it\u2019s mounted. I didn\u2019t even know a device\u2019s content would be available even after unmounted! TIL. To unmount and run the next steps I will need "),Ee=a(Ie,"CODE",{});var xs=i(Ee);Nt=n(xs,"sudo"),xs.forEach(t),Mt=n(Ie," to gain superuser permissions"),Ie.forEach(t),Ye=p(e),V=a(e,"PRE",{class:!0});var Zs=i(V);Zs.forEach(t),We=p(e),B=a(e,"H3",{id:!0});var ss=i(B);O=a(ss,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Ps=i(O);ke=a(Ps,"SPAN",{class:!0}),i(ke).forEach(t),Ps.forEach(t),Ut=n(ss,"Step 4: reorder the files"),ss.forEach(t),qe=p(e),Q=a(e,"P",{});var Bs=i(Q);Vt=n(Bs,"Now I am ready to reorder the files"),Bs.forEach(t),Ge=p(e),j=a(e,"PRE",{class:!0});var zs=i(j);zs.forEach(t),Xe=p(e),C=a(e,"H2",{id:!0});var os=i(C);F=a(os,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Os=i(F);we=a(Os,"SPAN",{class:!0}),i(we).forEach(t),Os.forEach(t),jt=n(os,"And that was it."),os.forEach(t),Ze=p(e),w=a(e,"P",{});var Se=i(w);Yt=n(Se,"It only takes a few seconds. It\u2019s a great little tool. Thanks Boris! If you enter "),be=a(Se,"CODE",{});var Cs=i(be);Wt=n(Cs,"fatsort -h"),Cs.forEach(t),qt=n(Se," you can "),Y=a(Se,"A",{href:!0,rel:!0});var Fs=i(Y);Gt=n(Fs,"see some of the options you can pass to it"),Fs.forEach(t),Se.forEach(t),ze=p(e),R=a(e,"H2",{id:!0});var as=i(R);H=a(as,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Rs=i(H);ye=a(Rs,"SPAN",{class:!0}),i(ye).forEach(t),Rs.forEach(t),Xt=n(as,"Prior art"),as.forEach(t),Je=p(e),L=a(e,"UL",{});var Qe=i(L);_e=a(Qe,"LI",{});var Hs=i(_e);W=a(Hs,"A",{href:!0,rel:!0});var Ls=i(W);Zt=n(Ls,"fatsort homepage"),Ls.forEach(t),Hs.forEach(t),zt=p(Qe),q=a(Qe,"LI",{});var $e=i(q);Jt=n($e,"I found "),G=a($e,"A",{href:!0,rel:!0});var Ns=i(G);Kt=n(Ns,"useful information about fatsort"),Ns.forEach(t),Qt=n($e," in a blog called \u2018Unfinished Bitness\u2019"),$e.forEach(t),Qe.forEach(t),this.h()},h(){u(ee,"class","icon icon-link"),u(b,"aria-hidden","true"),u(b,"tabindex","-1"),u(b,"href","#fat-formatting"),u(m,"id","fat-formatting"),u(le,"class","icon icon-link"),u(_,"aria-hidden","true"),u(_,"tabindex","-1"),u(_,"href","#enter-fatsort"),u(y,"id","enter-fatsort"),u(ne,"class","icon icon-link"),u(S,"aria-hidden","true"),u(S,"tabindex","-1"),u(S,"href","#step-1-install-it"),u(I,"id","step-1-install-it"),u(N,"class","language-bash"),u(ue,"class","icon icon-link"),u(A,"aria-hidden","true"),u(A,"tabindex","-1"),u(A,"href","#step-2-find-out-where-the-drive-is-mounted"),u(T,"id","step-2-find-out-where-the-drive-is-mounted"),u(M,"class","language-bash"),u(U,"class","language-bash"),u(me,"class","icon icon-link"),u(P,"aria-hidden","true"),u(P,"tabindex","-1"),u(P,"href","#step-3-unmount-the-drive"),u(x,"id","step-3-unmount-the-drive"),u(V,"class","language-bash"),u(ke,"class","icon icon-link"),u(O,"aria-hidden","true"),u(O,"tabindex","-1"),u(O,"href","#step-4-reorder-the-files"),u(B,"id","step-4-reorder-the-files"),u(j,"class","language-bash"),u(we,"class","icon icon-link"),u(F,"aria-hidden","true"),u(F,"tabindex","-1"),u(F,"href","#and-that-was-it"),u(C,"id","and-that-was-it"),u(Y,"href","https://fatsort.sourceforge.io/fatsort.1.html"),u(Y,"rel","nofollow"),u(ye,"class","icon icon-link"),u(H,"aria-hidden","true"),u(H,"tabindex","-1"),u(H,"href","#prior-art"),u(R,"id","prior-art"),u(W,"href","https://fatsort.sourceforge.io/"),u(W,"rel","nofollow"),u(G,"href","https://unfinishedbitness.info/2014/04/16/alphabetically-sorting-fat-usb-drives-with-mac-osx/"),u(G,"rel","nofollow")},m(e,r){d(e,m,r),s(m,b),s(b,ee),s(m,ge),d(e,Te,r),d(e,X,r),s(X,et),d(e,Ae,r),d(e,Z,r),s(Z,tt),d(e,De,r),d(e,c,r),s(c,st),s(c,te),s(te,ot),s(c,at),s(c,se),s(se,it),s(c,rt),s(c,oe),s(oe,lt),s(c,nt),s(c,ae),s(ae,ut),s(c,dt),s(c,ie),s(ie,ft),s(c,pt),s(c,re),s(re,ct),s(c,ht),d(e,xe,r),d(e,z,r),s(z,mt),d(e,Pe,r),d(e,y,r),s(y,_),s(_,le),s(y,vt),d(e,Be,r),d(e,J,r),s(J,Et),d(e,Oe,r),d(e,I,r),s(I,S),s(S,ne),s(I,kt),d(e,Ce,r),d(e,K,r),s(K,wt),d(e,Fe,r),d(e,N,r),N.innerHTML=Us,d(e,Re,r),d(e,T,r),s(T,A),s(A,ue),s(T,bt),d(e,He,r),d(e,v,r),s(v,yt),s(v,de),s(de,_t),s(v,It),s(v,fe),s(fe,St),s(v,Tt),d(e,Le,r),d(e,M,r),M.innerHTML=Vs,d(e,Ne,r),d(e,E,r),s(E,At),s(E,pe),s(pe,Dt),s(E,xt),s(E,ce),s(ce,Pt),s(E,Bt),d(e,Me,r),d(e,U,r),U.innerHTML=js,d(e,Ue,r),d(e,D,r),s(D,Ot),s(D,he),s(he,Ct),s(D,Ft),d(e,Ve,r),d(e,x,r),s(x,P),s(P,me),s(x,Rt),d(e,je,r),d(e,k,r),s(k,ve),s(ve,Ht),s(k,Lt),s(k,Ee),s(Ee,Nt),s(k,Mt),d(e,Ye,r),d(e,V,r),V.innerHTML=Ys,d(e,We,r),d(e,B,r),s(B,O),s(O,ke),s(B,Ut),d(e,qe,r),d(e,Q,r),s(Q,Vt),d(e,Ge,r),d(e,j,r),j.innerHTML=Ws,d(e,Xe,r),d(e,C,r),s(C,F),s(F,we),s(C,jt),d(e,Ze,r),d(e,w,r),s(w,Yt),s(w,be),s(be,Wt),s(w,qt),s(w,Y),s(Y,Gt),d(e,ze,r),d(e,R,r),s(R,H),s(H,ye),s(R,Xt),d(e,Je,r),d(e,L,r),s(L,_e),s(_e,W),s(W,Zt),s(L,zt),s(L,q),s(q,Jt),s(q,G),s(G,Kt),s(q,Qt)},p:is,i:is,o:is,d(e){e&&t(m),e&&t(Te),e&&t(X),e&&t(Ae),e&&t(Z),e&&t(De),e&&t(c),e&&t(xe),e&&t(z),e&&t(Pe),e&&t(y),e&&t(Be),e&&t(J),e&&t(Oe),e&&t(I),e&&t(Ce),e&&t(K),e&&t(Fe),e&&t(N),e&&t(Re),e&&t(T),e&&t(He),e&&t(v),e&&t(Le),e&&t(M),e&&t(Ne),e&&t(E),e&&t(Me),e&&t(U),e&&t(Ue),e&&t(D),e&&t(Ve),e&&t(x),e&&t(je),e&&t(k),e&&t(Ye),e&&t(V),e&&t(We),e&&t(B),e&&t(qe),e&&t(Q),e&&t(Ge),e&&t(j),e&&t(Xe),e&&t(C),e&&t(Ze),e&&t(w),e&&t(ze),e&&t(R),e&&t(Je),e&&t(L)}}}const eo={excerpt:'I copy audiobooks from CDs to USB sticks to play them in cars and random device like old radios. But often those devices play the files out of order. Reordering files in <abbr title="File Allocation Table">FAT</abbr> USB sticks is harder than I thought. Luckily, a chap by the name of Boris Leidner has written a useful tool for that.',date:"2022-04-01T00:00:00.000Z",draft:!1,archived:!1,title:"Reordering audio files in a FAT USB stick",tags:["tools"]};class to extends Js{constructor(m){super(),Ks(this,m,null,$s,Qs,{})}}export{to as default,eo as metadata};
