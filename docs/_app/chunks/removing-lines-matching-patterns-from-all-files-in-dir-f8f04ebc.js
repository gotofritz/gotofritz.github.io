import{S as Ra,i as Ca,s as Fa,e as l,t as r,k as m,c as o,a as s,h as i,d as a,m as c,b as n,g as f,I as t,E as $t}from"./index-6e518972.js";function Ba(La){let E,qe,N,Ne,Ue,ye,b,k,W,$e,Te,O,Aa=`<code class="language-sh"><span class="token function">find</span> /PTH/TO/FILES/*.txt <span class="token parameter variable">-type</span> f <span class="token operator">|</span> <span class="token punctuation"></span><span class="token punctuation"></span>
  <span class="token function">xargs</span> <span class="token function">sed</span> <span class="token parameter variable">-i.bak</span> <span class="token parameter variable">-f</span> /PTH/TO/SED_RULES.sed</code>`,De,U,je,Se,y,T,Y,We,ge,h,Z,Ye,G,Ze,J,Ge,K,Je,Q,Ke,V,Qe,X,Ve,ee,Xe,te,et,ae,tt,le,at,oe,lt,se,ot,re,st,Le,w,D,ie,rt,ne,it,nt,Ae,x,R,dt,ft,de,ht,mt,fe,ct,pt,Pe,S,g,he,ut,ze,$,vt,Ie,C,Pa=`<code class="language-sh">$ <span class="token function">sed</span> <span class="token string">'s/[[:blank:]]*$//'</span> some-text-file.txt
1st line of some-text-file.txt
2nd line
<span class="token punctuation">..</span><span class="token punctuation">..</span></code>`,He,L,A,me,xt,Oe,u,Et,ce,wt,_t,pe,bt,kt,ue,yt,Tt,ve,Dt,St,Re,F,za=`<code class="language-sh"><span class="token comment"># illegal-pizza-toppings.sed</span>
/pineapple/d
/ketchup/d

<span class="token comment"># pizzas.txt</span>
margherita: tomato, mozzarella
hawai: tomato, mozzarella, ham pineapple
fiorentina:  tomato, mozzarella, spinach, egg

$ <span class="token function">sed</span> <span class="token parameter variable">-f</span> illegal-pizza-toppings.sed pizzas.txt
margherita: tomato, mozzarella
fiorentina: tomato, mozzarella, spinach, egg</code>`,Ce,P,z,xe,gt,Fe,v,Lt,j,At,Pt,Ee,zt,It,we,Ht,Ot,Be,I,_e,B,Rt,Ct,be,M,Ft;return{c(){E=l("p"),qe=r("A typical use case was when "),N=l("a"),Ne=r("rebuilding this site with Sveltekit"),Ue=r(". I had a bunch of markdown files who had a been through a lot of migrations from tool to tool. The frontmatter had gotten messy, it was interfering with Sveltekit."),ye=m(),b=l("h2"),k=l("a"),W=l("span"),$e=r("TL;DR: the command"),Te=m(),O=l("pre"),De=m(),U=l("p"),je=r("Read further for more explanations"),Se=m(),y=l("h3"),T=l("a"),Y=l("span"),We=r("Breaking down the command"),ge=m(),h=l("dl"),Z=l("dt"),Ye=r("find /PTH/TO/FILES/*.txt"),G=l("dd"),Ze=r("use the `find` command on all files that match `/PTH/TO/FILES/*.txt`"),J=l("dt"),Ge=r("-type f"),K=l("dd"),Je=r("ignore directories - an extra precaution which you may not need"),Q=l("dt"),Ke=r("|"),V=l("dd"),Qe=r("every filename you find will be passed to..."),X=l("dt"),Ve=r("xargs"),ee=l("dd"),Xe=r("transform what it receives (i.e., the filename) into a CLI argument for ..."),te=l("dt"),et=r("sed"),ae=l("dd"),tt=r("So that will be equivalent to `sed filename1`, `sed filename2`, ..."),le=l("dt"),at=r("-i.bak"),oe=l("dd"),lt=r("`-i` will make the changes in place. Macs force you to create a backup file, for your own protection. In this case they will be called `filename1.bak` `filename2.bak` ..."),se=l("dt"),ot=r("-f /PTH/TO/SED_RULES.sed"),re=l("dd"),st=r("Loads a list of scripts to apply from SED_RULES.sed. The file can be named everything, doesn't have to end with .sed"),Le=m(),w=l("h2"),D=l("a"),ie=l("span"),rt=r("What exactly "),ne=l("em"),it=r("is"),nt=r(" sed?"),Ae=m(),x=l("p"),R=l("a"),dt=r("Sed"),ft=r(" is a stream editor. A stream editor goes through a text file once, from top to bottom one line at the time. As it goes through it applies a sequence of "),de=l("em"),ht=r("scripts"),mt=r(", and then the text comes out at the other end. The scripts can be very short, and look pretty much like regular expressions. For example "),fe=l("code"),ct=r("s/he/they/g"),pt=r(". They can rearrange the line of text, delete it or apply other transforms. And also capture some of the text and accumulate it until the end."),Pe=m(),S=l("h2"),g=l("a"),he=l("span"),ut=r("Example: remove all blanks from end of each line"),ze=m(),$=l("p"),vt=r("For small jobs you pass those scripts as command line arguments. For example the one liner below will remove all blanks at the end of each line, and spit out the output to the CLI."),Ie=m(),C=l("pre"),He=m(),L=l("h2"),A=l("a"),me=l("span"),xt=r("Example: load a list of delete commands from a file"),Oe=m(),u=l("p"),Et=r("But if you want to reuse the patterns you can put them in a text file, one per line, and tell sed to load them from there. That can also be useful if there are too many patterns for the CLI and writing them all gets awkward. You can pass the file containing the patters with the "),ce=l("code"),wt=r("-f"),_t=r(" flag. The example below will apply "),pe=l("code"),bt=r("illegal-pizza-toppings.sed"),kt=r(" to the text stream. "),ue=l("code"),yt=r("/something/d"),Tt=r(" is the sed command which will delete the whole line if "),ve=l("code"),Dt=r("something"),St=r(" is in it."),Re=m(),F=l("pre"),Ce=m(),P=l("h2"),z=l("a"),xe=l("span"),gt=r("Prior art"),Fe=m(),v=l("p"),Lt=r("As always there is more on "),j=l("abbr"),At=r("SO"),Pt=r(". For example you could achieve the same with "),Ee=l("code"),zt=r("grep -v xxx"),It=r(", which passes the lines who "),we=l("em"),Ht=r("do not"),Ot=r(" match xxx. But the command above is my favourite"),Be=m(),I=l("ul"),_e=l("li"),B=l("a"),Rt=r("sed - delete lines taking patterns from external file"),Ct=m(),be=l("li"),M=l("a"),Ft=r("Remove line of text from multiple files in Linux"),this.h()},l(e){E=o(e,"P",{});var d=s(E);qe=i(d,"A typical use case was when "),N=o(d,"A",{href:!0});var jt=s(N);Ne=i(jt,"rebuilding this site with Sveltekit"),jt.forEach(a),Ue=i(d,". I had a bunch of markdown files who had a been through a lot of migrations from tool to tool. The frontmatter had gotten messy, it was interfering with Sveltekit."),d.forEach(a),ye=c(e),b=o(e,"H2",{id:!0});var Bt=s(b);k=o(Bt,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Wt=s(k);W=o(Wt,"SPAN",{class:!0}),s(W).forEach(a),Wt.forEach(a),$e=i(Bt,"TL;DR: the command"),Bt.forEach(a),Te=c(e),O=o(e,"PRE",{class:!0});var Ia=s(O);Ia.forEach(a),De=c(e),U=o(e,"P",{});var Yt=s(U);je=i(Yt,"Read further for more explanations"),Yt.forEach(a),Se=c(e),y=o(e,"H3",{id:!0});var Mt=s(y);T=o(Mt,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Zt=s(T);Y=o(Zt,"SPAN",{class:!0}),s(Y).forEach(a),Zt.forEach(a),We=i(Mt,"Breaking down the command"),Mt.forEach(a),ge=c(e),h=o(e,"DL",{class:!0});var p=s(h);Z=o(p,"DT",{});var Gt=s(Z);Ye=i(Gt,"find /PTH/TO/FILES/*.txt"),Gt.forEach(a),G=o(p,"DD",{});var Jt=s(G);Ze=i(Jt,"use the `find` command on all files that match `/PTH/TO/FILES/*.txt`"),Jt.forEach(a),J=o(p,"DT",{});var Kt=s(J);Ge=i(Kt,"-type f"),Kt.forEach(a),K=o(p,"DD",{});var Qt=s(K);Je=i(Qt,"ignore directories - an extra precaution which you may not need"),Qt.forEach(a),Q=o(p,"DT",{});var Vt=s(Q);Ke=i(Vt,"|"),Vt.forEach(a),V=o(p,"DD",{});var Xt=s(V);Qe=i(Xt,"every filename you find will be passed to..."),Xt.forEach(a),X=o(p,"DT",{});var ea=s(X);Ve=i(ea,"xargs"),ea.forEach(a),ee=o(p,"DD",{});var ta=s(ee);Xe=i(ta,"transform what it receives (i.e., the filename) into a CLI argument for ..."),ta.forEach(a),te=o(p,"DT",{});var aa=s(te);et=i(aa,"sed"),aa.forEach(a),ae=o(p,"DD",{});var la=s(ae);tt=i(la,"So that will be equivalent to `sed filename1`, `sed filename2`, ..."),la.forEach(a),le=o(p,"DT",{});var oa=s(le);at=i(oa,"-i.bak"),oa.forEach(a),oe=o(p,"DD",{});var sa=s(oe);lt=i(sa,"`-i` will make the changes in place. Macs force you to create a backup file, for your own protection. In this case they will be called `filename1.bak` `filename2.bak` ..."),sa.forEach(a),se=o(p,"DT",{});var ra=s(se);ot=i(ra,"-f /PTH/TO/SED_RULES.sed"),ra.forEach(a),re=o(p,"DD",{});var ia=s(re);st=i(ia,"Loads a list of scripts to apply from SED_RULES.sed. The file can be named everything, doesn't have to end with .sed"),ia.forEach(a),p.forEach(a),Le=c(e),w=o(e,"H2",{id:!0});var ke=s(w);D=o(ke,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var na=s(D);ie=o(na,"SPAN",{class:!0}),s(ie).forEach(a),na.forEach(a),rt=i(ke,"What exactly "),ne=o(ke,"EM",{});var da=s(ne);it=i(da,"is"),da.forEach(a),nt=i(ke," sed?"),ke.forEach(a),Ae=c(e),x=o(e,"P",{});var q=s(x);R=o(q,"A",{href:!0,rel:!0});var fa=s(R);dt=i(fa,"Sed"),fa.forEach(a),ft=i(q," is a stream editor. A stream editor goes through a text file once, from top to bottom one line at the time. As it goes through it applies a sequence of "),de=o(q,"EM",{});var ha=s(de);ht=i(ha,"scripts"),ha.forEach(a),mt=i(q,", and then the text comes out at the other end. The scripts can be very short, and look pretty much like regular expressions. For example "),fe=o(q,"CODE",{});var ma=s(fe);ct=i(ma,"s/he/they/g"),ma.forEach(a),pt=i(q,". They can rearrange the line of text, delete it or apply other transforms. And also capture some of the text and accumulate it until the end."),q.forEach(a),Pe=c(e),S=o(e,"H2",{id:!0});var qt=s(S);g=o(qt,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var ca=s(g);he=o(ca,"SPAN",{class:!0}),s(he).forEach(a),ca.forEach(a),ut=i(qt,"Example: remove all blanks from end of each line"),qt.forEach(a),ze=c(e),$=o(e,"P",{});var pa=s($);vt=i(pa,"For small jobs you pass those scripts as command line arguments. For example the one liner below will remove all blanks at the end of each line, and spit out the output to the CLI."),pa.forEach(a),Ie=c(e),C=o(e,"PRE",{class:!0});var Ha=s(C);Ha.forEach(a),He=c(e),L=o(e,"H2",{id:!0});var Nt=s(L);A=o(Nt,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var ua=s(A);me=o(ua,"SPAN",{class:!0}),s(me).forEach(a),ua.forEach(a),xt=i(Nt,"Example: load a list of delete commands from a file"),Nt.forEach(a),Oe=c(e),u=o(e,"P",{});var _=s(u);Et=i(_,"But if you want to reuse the patterns you can put them in a text file, one per line, and tell sed to load them from there. That can also be useful if there are too many patterns for the CLI and writing them all gets awkward. You can pass the file containing the patters with the "),ce=o(_,"CODE",{});var va=s(ce);wt=i(va,"-f"),va.forEach(a),_t=i(_," flag. The example below will apply "),pe=o(_,"CODE",{});var xa=s(pe);bt=i(xa,"illegal-pizza-toppings.sed"),xa.forEach(a),kt=i(_," to the text stream. "),ue=o(_,"CODE",{});var Ea=s(ue);yt=i(Ea,"/something/d"),Ea.forEach(a),Tt=i(_," is the sed command which will delete the whole line if "),ve=o(_,"CODE",{});var wa=s(ve);Dt=i(wa,"something"),wa.forEach(a),St=i(_," is in it."),_.forEach(a),Re=c(e),F=o(e,"PRE",{class:!0});var Oa=s(F);Oa.forEach(a),Ce=c(e),P=o(e,"H2",{id:!0});var Ut=s(P);z=o(Ut,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var _a=s(z);xe=o(_a,"SPAN",{class:!0}),s(xe).forEach(a),_a.forEach(a),gt=i(Ut,"Prior art"),Ut.forEach(a),Fe=c(e),v=o(e,"P",{});var H=s(v);Lt=i(H,"As always there is more on "),j=o(H,"ABBR",{title:!0});var ba=s(j);At=i(ba,"SO"),ba.forEach(a),Pt=i(H,". For example you could achieve the same with "),Ee=o(H,"CODE",{});var ka=s(Ee);zt=i(ka,"grep -v xxx"),ka.forEach(a),It=i(H,", which passes the lines who "),we=o(H,"EM",{});var ya=s(we);Ht=i(ya,"do not"),ya.forEach(a),Ot=i(H," match xxx. But the command above is my favourite"),H.forEach(a),Be=c(e),I=o(e,"UL",{});var Me=s(I);_e=o(Me,"LI",{});var Ta=s(_e);B=o(Ta,"A",{href:!0,rel:!0});var Da=s(B);Rt=i(Da,"sed - delete lines taking patterns from external file"),Da.forEach(a),Ta.forEach(a),Ct=c(Me),be=o(Me,"LI",{});var Sa=s(be);M=o(Sa,"A",{href:!0,rel:!0});var ga=s(M);Ft=i(ga,"Remove line of text from multiple files in Linux"),ga.forEach(a),Sa.forEach(a),Me.forEach(a),this.h()},h(){n(N,"href","/blog/blog-with-sveltekit-and-markdown"),n(W,"class","icon icon-link"),n(k,"aria-hidden","true"),n(k,"tabindex","-1"),n(k,"href","#tldr-the-command"),n(b,"id","tldr-the-command"),n(O,"class","language-sh"),n(Y,"class","icon icon-link"),n(T,"aria-hidden","true"),n(T,"tabindex","-1"),n(T,"href","#breaking-down-the-command"),n(y,"id","breaking-down-the-command"),n(h,"class","code-breakdown"),n(ie,"class","icon icon-link"),n(D,"aria-hidden","true"),n(D,"tabindex","-1"),n(D,"href","#what-exactly-is-sed"),n(w,"id","what-exactly-is-sed"),n(R,"href","https://www.gnu.org/software/sed/manual/html_node/index.html"),n(R,"rel","nofollow"),n(he,"class","icon icon-link"),n(g,"aria-hidden","true"),n(g,"tabindex","-1"),n(g,"href","#example-remove-all-blanks-from-end-of-each-line"),n(S,"id","example-remove-all-blanks-from-end-of-each-line"),n(C,"class","language-sh"),n(me,"class","icon icon-link"),n(A,"aria-hidden","true"),n(A,"tabindex","-1"),n(A,"href","#example-load-a-list-of-delete-commands-from-a-file"),n(L,"id","example-load-a-list-of-delete-commands-from-a-file"),n(F,"class","language-sh"),n(xe,"class","icon icon-link"),n(z,"aria-hidden","true"),n(z,"tabindex","-1"),n(z,"href","#prior-art"),n(P,"id","prior-art"),n(j,"title","Stack Overflow"),n(B,"href","https://superuser.com/questions/1376305/sed-delete-lines-taking-patterns-from-external-file"),n(B,"rel","nofollow"),n(M,"href","https://stackoverflow.com/questions/1182756/remove-line-of-text-from-multiple-files-in-linux"),n(M,"rel","nofollow")},m(e,d){f(e,E,d),t(E,qe),t(E,N),t(N,Ne),t(E,Ue),f(e,ye,d),f(e,b,d),t(b,k),t(k,W),t(b,$e),f(e,Te,d),f(e,O,d),O.innerHTML=Aa,f(e,De,d),f(e,U,d),t(U,je),f(e,Se,d),f(e,y,d),t(y,T),t(T,Y),t(y,We),f(e,ge,d),f(e,h,d),t(h,Z),t(Z,Ye),t(h,G),t(G,Ze),t(h,J),t(J,Ge),t(h,K),t(K,Je),t(h,Q),t(Q,Ke),t(h,V),t(V,Qe),t(h,X),t(X,Ve),t(h,ee),t(ee,Xe),t(h,te),t(te,et),t(h,ae),t(ae,tt),t(h,le),t(le,at),t(h,oe),t(oe,lt),t(h,se),t(se,ot),t(h,re),t(re,st),f(e,Le,d),f(e,w,d),t(w,D),t(D,ie),t(w,rt),t(w,ne),t(ne,it),t(w,nt),f(e,Ae,d),f(e,x,d),t(x,R),t(R,dt),t(x,ft),t(x,de),t(de,ht),t(x,mt),t(x,fe),t(fe,ct),t(x,pt),f(e,Pe,d),f(e,S,d),t(S,g),t(g,he),t(S,ut),f(e,ze,d),f(e,$,d),t($,vt),f(e,Ie,d),f(e,C,d),C.innerHTML=Pa,f(e,He,d),f(e,L,d),t(L,A),t(A,me),t(L,xt),f(e,Oe,d),f(e,u,d),t(u,Et),t(u,ce),t(ce,wt),t(u,_t),t(u,pe),t(pe,bt),t(u,kt),t(u,ue),t(ue,yt),t(u,Tt),t(u,ve),t(ve,Dt),t(u,St),f(e,Re,d),f(e,F,d),F.innerHTML=za,f(e,Ce,d),f(e,P,d),t(P,z),t(z,xe),t(P,gt),f(e,Fe,d),f(e,v,d),t(v,Lt),t(v,j),t(j,At),t(v,Pt),t(v,Ee),t(Ee,zt),t(v,It),t(v,we),t(we,Ht),t(v,Ot),f(e,Be,d),f(e,I,d),t(I,_e),t(_e,B),t(B,Rt),t(I,Ct),t(I,be),t(be,M),t(M,Ft)},p:$t,i:$t,o:$t,d(e){e&&a(E),e&&a(ye),e&&a(b),e&&a(Te),e&&a(O),e&&a(De),e&&a(U),e&&a(Se),e&&a(y),e&&a(ge),e&&a(h),e&&a(Le),e&&a(w),e&&a(Ae),e&&a(x),e&&a(Pe),e&&a(S),e&&a(ze),e&&a($),e&&a(Ie),e&&a(C),e&&a(He),e&&a(L),e&&a(Oe),e&&a(u),e&&a(Re),e&&a(F),e&&a(Ce),e&&a(P),e&&a(Fe),e&&a(v),e&&a(Be),e&&a(I)}}}const qa={date:"2022-05-22T13:10:12.382Z",title:"Remove lines matching some patterns from all files in a dir",tags:["bash","sed"],excerpt:"A CLI task I find myself doing often with sed",is_empty:!1};class Na extends Ra{constructor(E){super(),Ca(this,E,null,Ba,Fa,{})}}export{Na as default,qa as metadata};
